<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>9&nbsp; 实践教学示例：EP 因子分析、增强与组合优化 – 量化投资课程讲义</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./12_alternative.html" rel="next">
<link href="./11_timing.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2486e1f0a3ee9ee1fc393803a1361cdb.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-4140c5528bad55d065fb0dfc8d36ff91.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./lab11_EP.html"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">实践教学示例：EP 因子分析、增强与组合优化</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">量化投资课程讲义</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">前言</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01_emh.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">有效市场假说 (EMH)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02_capm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">资本资产定价模型 (CAPM)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab02_capmtest.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">资本资产定价模型 (CAPM) 实证检验</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03_ff3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Fama-French三因子模型</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab03_ff3test.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">实践：构建和回测中国特色三因子模型(CH-3)</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10_selecting.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">收益模型与组合优化</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11_timing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">因子择时与风格分析</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lab11_EP.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">实践教学示例：EP 因子分析、增强与组合优化</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12_alternative.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">因子投资展望：另类数据与机器学习</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./project1_factor.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">项目1：因子投资策略构建</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./project2_enhance.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">项目2：因子投资策略的优化与提升</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#目标" id="toc-目标" class="nav-link active" data-scroll-target="#目标"><span class="header-section-number">9.1</span> 目标</a></li>
  <li><a href="#背景知识回顾" id="toc-背景知识回顾" class="nav-link" data-scroll-target="#背景知识回顾"><span class="header-section-number">9.2</span> 背景知识回顾</a></li>
  <li><a href="#part-1-ep-因子基础分析" id="toc-part-1-ep-因子基础分析" class="nav-link" data-scroll-target="#part-1-ep-因子基础分析"><span class="header-section-number">9.3</span> Part 1: EP 因子基础分析</a>
  <ul class="collapse">
  <li><a href="#因子逻辑与构建-intuitiveness-construction" id="toc-因子逻辑与构建-intuitiveness-construction" class="nav-link" data-scroll-target="#因子逻辑与构建-intuitiveness-construction"><span class="header-section-number">9.3.1</span> 1.1 因子逻辑与构建 (Intuitiveness &amp; Construction)</a></li>
  <li><a href="#因子绩效评估-persistence-robustness" id="toc-因子绩效评估-persistence-robustness" class="nav-link" data-scroll-target="#因子绩效评估-persistence-robustness"><span class="header-section-number">9.3.2</span> 1.2 因子绩效评估 (Persistence &amp; Robustness)</a></li>
  <li><a href="#因子优缺点与可投资性-investability" id="toc-因子优缺点与可投资性-investability" class="nav-link" data-scroll-target="#因子优缺点与可投资性-investability"><span class="header-section-number">9.3.3</span> 1.3 因子优缺点与可投资性 (Investability)</a></li>
  </ul></li>
  <li><a href="#part-2-ep-因子增强策略" id="toc-part-2-ep-因子增强策略" class="nav-link" data-scroll-target="#part-2-ep-因子增强策略"><span class="header-section-number">9.4</span> Part 2: EP 因子增强策略</a>
  <ul class="collapse">
  <li><a href="#增强-1-考虑行业差异-industry-adjustment" id="toc-增强-1-考虑行业差异-industry-adjustment" class="nav-link" data-scroll-target="#增强-1-考虑行业差异-industry-adjustment"><span class="header-section-number">9.4.1</span> 增强 1: 考虑行业差异 (Industry Adjustment)</a></li>
  <li><a href="#增强-2-结合质量因子-combining-with-quality" id="toc-增强-2-结合质量因子-combining-with-quality" class="nav-link" data-scroll-target="#增强-2-结合质量因子-combining-with-quality"><span class="header-section-number">9.4.2</span> 增强 2: 结合质量因子 (Combining with Quality)</a></li>
  <li><a href="#增强-3-动态择时-factor-timing" id="toc-增强-3-动态择时-factor-timing" class="nav-link" data-scroll-target="#增强-3-动态择时-factor-timing"><span class="header-section-number">9.4.3</span> 增强 3: 动态择时 (Factor Timing)</a></li>
  <li><a href="#增强-4-改进-ep-计算-robust-calculation" id="toc-增强-4-改进-ep-计算-robust-calculation" class="nav-link" data-scroll-target="#增强-4-改进-ep-计算-robust-calculation"><span class="header-section-number">9.4.4</span> 增强 4: 改进 EP 计算 (Robust Calculation)</a></li>
  </ul></li>
  <li><a href="#part-4-将-ep-因子融入投资组合优化" id="toc-part-4-将-ep-因子融入投资组合优化" class="nav-link" data-scroll-target="#part-4-将-ep-因子融入投资组合优化"><span class="header-section-number">9.5</span> Part 4: 将 EP 因子融入投资组合优化</a>
  <ul class="collapse">
  <li><a href="#ep-因子作为-alpha-信号-μ" id="toc-ep-因子作为-alpha-信号-μ" class="nav-link" data-scroll-target="#ep-因子作为-alpha-信号-μ"><span class="header-section-number">9.5.1</span> 4.1 EP 因子作为 Alpha 信号 (μ)</a></li>
  <li><a href="#投资组合优化流程" id="toc-投资组合优化流程" class="nav-link" data-scroll-target="#投资组合优化流程"><span class="header-section-number">9.5.2</span> 4.2 投资组合优化流程</a></li>
  <li><a href="#优化中的考量与挑战" id="toc-优化中的考量与挑战" class="nav-link" data-scroll-target="#优化中的考量与挑战"><span class="header-section-number">9.5.3</span> 4.3 优化中的考量与挑战</a></li>
  <li><a href="#概念性优化流程代码示例" id="toc-概念性优化流程代码示例" class="nav-link" data-scroll-target="#概念性优化流程代码示例"><span class="header-section-number">9.5.4</span> 4.4 概念性优化流程代码示例</a></li>
  </ul></li>
  <li><a href="#准备优化的输入数据" id="toc-准备优化的输入数据" class="nav-link" data-scroll-target="#准备优化的输入数据"><span class="header-section-number">10</span> — 1. 准备优化的输入数据 —</a></li>
  <li><a href="#使用之前生成的最新日期数据" id="toc-使用之前生成的最新日期数据" class="nav-link" data-scroll-target="#使用之前生成的最新日期数据"><span class="header-section-number">11</span> 使用之前生成的最新日期数据</a></li>
  <li><a href="#我们选择使用ep质量组合信号作为alpha输入" id="toc-我们选择使用ep质量组合信号作为alpha输入" class="nav-link" data-scroll-target="#我们选择使用ep质量组合信号作为alpha输入"><span class="header-section-number">12</span> 我们选择使用EP+质量组合信号作为Alpha输入</a></li>
  <li><a href="#alpha向量-预期收益" id="toc-alpha向量-预期收益" class="nav-link" data-scroll-target="#alpha向量-预期收益"><span class="header-section-number">13</span> Alpha向量 (预期收益)</a></li>
  <li><a href="#构建风险模型" id="toc-构建风险模型" class="nav-link" data-scroll-target="#构建风险模型"><span class="header-section-number">14</span> — 2. 构建风险模型 —</a></li>
  <li><a href="#在实际应用中应该使用像barra这样的因子风险模型" id="toc-在实际应用中应该使用像barra这样的因子风险模型" class="nav-link" data-scroll-target="#在实际应用中应该使用像barra这样的因子风险模型"><span class="header-section-number">15</span> 在实际应用中，应该使用像Barra这样的因子风险模型</a></li>
  <li><a href="#或者从历史数据中估计样本协方差矩阵" id="toc-或者从历史数据中估计样本协方差矩阵" class="nav-link" data-scroll-target="#或者从历史数据中估计样本协方差矩阵"><span class="header-section-number">16</span> 或者从历史数据中估计样本协方差矩阵</a></li>
  <li><a href="#这里我们使用一个简化的风险模型" id="toc-这里我们使用一个简化的风险模型" class="nav-link" data-scroll-target="#这里我们使用一个简化的风险模型"><span class="header-section-number">17</span> 这里我们使用一个简化的风险模型</a></li>
  <li><a href="#创建对角风险矩阵假设股票间独立加权为市值的倒数" id="toc-创建对角风险矩阵假设股票间独立加权为市值的倒数" class="nav-link" data-scroll-target="#创建对角风险矩阵假设股票间独立加权为市值的倒数"><span class="header-section-number">18</span> 创建对角风险矩阵（假设股票间独立，加权为市值的倒数）</a></li>
  <li><a href="#这是一个极度简化的风险模型仅用于示例" id="toc-这是一个极度简化的风险模型仅用于示例" class="nav-link" data-scroll-target="#这是一个极度简化的风险模型仅用于示例"><span class="header-section-number">19</span> 这是一个极度简化的风险模型，仅用于示例</a></li>
  <li><a href="#添加市场因子的影响" id="toc-添加市场因子的影响" class="nav-link" data-scroll-target="#添加市场因子的影响"><span class="header-section-number">20</span> 添加市场因子的影响</a></li>
  <li><a href="#最终协方差矩阵-特质风险-系统性风险" id="toc-最终协方差矩阵-特质风险-系统性风险" class="nav-link" data-scroll-target="#最终协方差矩阵-特质风险-系统性风险"><span class="header-section-number">21</span> 最终协方差矩阵 = 特质风险 + 系统性风险</a></li>
  <li><a href="#确保矩阵是半正定的" id="toc-确保矩阵是半正定的" class="nav-link" data-scroll-target="#确保矩阵是半正定的"><span class="header-section-number">22</span> 确保矩阵是半正定的</a></li>
  <li><a href="#设置优化参数" id="toc-设置优化参数" class="nav-link" data-scroll-target="#设置优化参数"><span class="header-section-number">23</span> — 3. 设置优化参数 —</a></li>
  <li><a href="#假设初始权重是等权重" id="toc-假设初始权重是等权重" class="nav-link" data-scroll-target="#假设初始权重是等权重"><span class="header-section-number">24</span> 假设初始权重是等权重</a></li>
  <li><a href="#不同约束条件下的投资组合优化" id="toc-不同约束条件下的投资组合优化" class="nav-link" data-scroll-target="#不同约束条件下的投资组合优化"><span class="header-section-number">25</span> — 4. 不同约束条件下的投资组合优化 —</a></li>
  <li><a href="#定义不同的约束条件组合" id="toc-定义不同的约束条件组合" class="nav-link" data-scroll-target="#定义不同的约束条件组合"><span class="header-section-number">26</span> 定义不同的约束条件组合</a></li>
  <li><a href="#添加行业中性约束" id="toc-添加行业中性约束" class="nav-link" data-scroll-target="#添加行业中性约束"><span class="header-section-number">27</span> 添加行业中性约束</a></li>
  <li><a href="#执行不同约束下的优化" id="toc-执行不同约束下的优化" class="nav-link" data-scroll-target="#执行不同约束下的优化"><span class="header-section-number">28</span> 执行不同约束下的优化</a></li>
  <li><a href="#分析优化结果" id="toc-分析优化结果" class="nav-link" data-scroll-target="#分析优化结果"><span class="header-section-number">29</span> — 5. 分析优化结果 —</a></li>
  <li><a href="#提取关键指标进行比较" id="toc-提取关键指标进行比较" class="nav-link" data-scroll-target="#提取关键指标进行比较"><span class="header-section-number">30</span> 提取关键指标进行比较</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">实践教学示例：EP 因子分析、增强与组合优化</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="目标" class="level2" data-number="9.1">
<h2 data-number="9.1" class="anchored" data-anchor-id="目标"><span class="header-section-number">9.1</span> 目标</h2>
<p>本示例旨在引导学生深入理解市盈率倒数 (Earnings-to-Price, EP) 这一经典价值因子。我们将回顾其基本原理、构建方法，分析其在中国市场的表现（参考 CH-3 模型实践），探讨如何基于理论知识对其进行增强，并最终学习如何将 EP 因子信号融入投资组合优化框架，以构建实际的量化投资组合。</p>
</section>
<section id="背景知识回顾" class="level2" data-number="9.2">
<h2 data-number="9.2" class="anchored" data-anchor-id="背景知识回顾"><span class="header-section-number">9.2</span> 背景知识回顾</h2>
<ul>
<li><strong>收益预测模型 (<code>10_selecting.qmd</code>)</strong>: 量化投资的核心是构建模型预测未来收益。预测变量（如 EP 因子）需要满足逻辑性、持续性、信息增量性、稳健性、可投资性、普适性等标准。EP 作为典型的价值类预测变量，其逻辑在于寻找被市场低估（即盈利能力相对于股价较高）的公司。</li>
<li><strong>投资组合优化 (<code>10_selecting.qmd</code>)</strong>: 获取预期收益信号 (<span class="math inline">\(\mu\)</span>) 后，需要通过优化技术，结合风险模型 (<span class="math inline">\(\Sigma\)</span>) 和各种约束条件，构建最优投资组合。常见的目标函数包括均值-方差优化 (MVO)。</li>
<li><strong>因子择时 (<code>11_timing.qmd</code>)</strong>: 因子收益存在时变性。因子择时尝试通过预测因子未来表现来动态调整因子权重。</li>
<li><strong>中国市场实践 (<code>lab03_ff3test.qmd</code>)</strong>: 在构建中国特色三因子 (CH-3) 模型时，研究发现 EP 比传统的账面市值比 (BM) 更能有效捕捉中国市场的价值效应。该实验展示了数据处理、分组和因子构建的过程。</li>
</ul>
<hr>
</section>
<section id="part-1-ep-因子基础分析" class="level2" data-number="9.3">
<h2 data-number="9.3" class="anchored" data-anchor-id="part-1-ep-因子基础分析"><span class="header-section-number">9.3</span> Part 1: EP 因子基础分析</h2>
<section id="因子逻辑与构建-intuitiveness-construction" class="level3" data-number="9.3.1">
<h3 data-number="9.3.1" class="anchored" data-anchor-id="因子逻辑与构建-intuitiveness-construction"><span class="header-section-number">9.3.1</span> 1.1 因子逻辑与构建 (Intuitiveness &amp; Construction)</h3>
<ul>
<li><strong>逻辑 (Rationale):</strong> EP 因子，即市盈率 (P/E) 的倒数，衡量的是公司盈利能力相对于其市场价值的大小。高 EP 通常意味着较低的市盈率。投资高 EP 股票背后的逻辑是：
<ol type="1">
<li><strong>价值投资</strong>: 认为市场可能暂时低估了这些公司的盈利能力，未来股价有向其内在价值回归的空间。</li>
<li><strong>风险补偿</strong>: 高 EP 公司可能承担着更高的风险（如盈利不稳定、增长前景不明朗），因此需要更高的预期回报来补偿投资者。</li>
</ol></li>
<li><strong>构建方法 (参考 <code>lab03_ff3test.qmd</code>):</strong>
<ol type="1">
<li><strong>数据准备</strong>: 获取股票的<strong>盈利数据</strong>（如归属于母公司股东的净利润，最好是扣除非经常性损益 <code>npexnr</code>）和<strong>市值数据</strong>（如 <code>Msmvttl</code> 或 <code>Mclsprc</code> * 流通股本）。注意盈利数据的滞后性。</li>
<li><strong>计算 EP</strong>: <span class="math inline">\(EP = \\frac{\\text{Earnings}}{\\text{Market Cap}}\)</span>。</li>
<li><strong>数据清洗</strong>: 剔除负 EP、处理异常值 (Winsorization, MAD)。</li>
<li><strong>分组构建 VMG 因子</strong>: 筛选股票池 (如剔除金融、公用事业、小市值) -&gt; 按 EP 排序分组 (低/中/高) -&gt; 计算组的市值加权收益 -&gt; 计算因子收益 <span class="math inline">\(VMG = R_{HighEP} - R_{LowEP}\)</span>。</li>
</ol></li>
</ul>
</section>
<section id="因子绩效评估-persistence-robustness" class="level3" data-number="9.3.2">
<h3 data-number="9.3.2" class="anchored" data-anchor-id="因子绩效评估-persistence-robustness"><span class="header-section-number">9.3.2</span> 1.2 因子绩效评估 (Persistence &amp; Robustness)</h3>
<ul>
<li><strong>历史表现 (Persistence):</strong>
<ul>
<li><strong>方法</strong>: 分析 VMG 因子时间序列的统计特性 (均值, t 值, IR) 或原始 EP 因子的 IC 值序列。</li>
<li><strong>预期</strong>: 长期平均收益为正，t 值显著。</li>
</ul></li>
<li><strong>稳健性考量 (Robustness):</strong>
<ul>
<li><strong>参数敏感性</strong>: 对盈利定义、分组阈值等是否敏感？</li>
<li><strong>市场环境</strong>: 不同市场周期表现如何？</li>
<li><strong>行业差异</strong>: EP 在行业间是否存在系统性差异？</li>
</ul></li>
</ul>
<section id="vmg因子绩效分析实践" class="level4" data-number="9.3.2.1">
<h4 data-number="9.3.2.1" class="anchored" data-anchor-id="vmg因子绩效分析实践"><span class="header-section-number">9.3.2.1</span> 1.2.1 VMG因子绩效分析实践</h4>
<p>下面我们展示如何对中国A股市场的VMG因子进行全面的绩效评估：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> stats</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 1. 加载数据 ---</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 假设我们已经构建了VMG因子收益的月度时间序列</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 从lab03_ff3test.qmd中可以看到，我们使用如下方法构建VMG:</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. 剔除金融、公用事业和市值最小的30%股票</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. 根据EP值将股票分为三组：低(G, 30%)、中(40%)、高(V, 30%)</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. 计算高EP组(V)和低EP组(G)的市值加权月度收益</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># 4. VMG = 高EP组收益 - 低EP组收益</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co"># 加载已经构建好的VMG月度收益序列（实际应用中从自己构建的因子中获取）</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co"># 这里仅作示例，假设我们已获得2010年1月至2022年12月的VMG月度收益率数据</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> {</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="st">'ym'</span>: pd.date_range(start<span class="op">=</span><span class="st">'2010-01-31'</span>, end<span class="op">=</span><span class="st">'2022-12-31'</span>, freq<span class="op">=</span><span class="st">'M'</span>),</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="st">'VMG'</span>: np.random.normal(<span class="fl">0.005</span>, <span class="fl">0.03</span>, <span class="dv">156</span>)  <span class="co"># 模拟月度收益，均值0.5%，波动率3%</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>vmg_returns <span class="op">=</span> pd.DataFrame(data)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>vmg_returns[<span class="st">'ym'</span>] <span class="op">=</span> vmg_returns[<span class="st">'ym'</span>].dt.strftime(<span class="st">'%Y%m'</span>)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>vmg_returns.set_index(<span class="st">'ym'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 2. 统计性分析 ---</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="co"># 计算月度VMG收益的基本统计量</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>vmg_mean <span class="op">=</span> vmg_returns[<span class="st">'VMG'</span>].mean()</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>vmg_std <span class="op">=</span> vmg_returns[<span class="st">'VMG'</span>].std()</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>vmg_t <span class="op">=</span> vmg_mean <span class="op">/</span> (vmg_std <span class="op">/</span> np.sqrt(<span class="bu">len</span>(vmg_returns)))</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>vmg_sharpe <span class="op">=</span> vmg_mean <span class="op">/</span> vmg_std <span class="op">*</span> np.sqrt(<span class="dv">12</span>)  <span class="co"># 年化夏普比率</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>vmg_positive_pct <span class="op">=</span> (vmg_returns[<span class="st">'VMG'</span>] <span class="op">&gt;</span> <span class="dv">0</span>).mean()  <span class="co"># 正收益月份比例</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>stats_df <span class="op">=</span> pd.DataFrame({</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="st">'指标'</span>: [<span class="st">'月均收益率'</span>, <span class="st">'月收益标准差'</span>, <span class="st">'t统计量'</span>, <span class="st">'年化夏普比率'</span>, <span class="st">'正收益月份比例'</span>],</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="st">'数值'</span>: [<span class="ss">f'</span><span class="sc">{</span>vmg_mean<span class="sc">:.2%}</span><span class="ss">'</span>, <span class="ss">f'</span><span class="sc">{</span>vmg_std<span class="sc">:.2%}</span><span class="ss">'</span>, <span class="ss">f'</span><span class="sc">{</span>vmg_t<span class="sc">:.2f}</span><span class="ss">'</span>, </span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>             <span class="ss">f'</span><span class="sc">{</span>vmg_sharpe<span class="sc">:.2f}</span><span class="ss">'</span>, <span class="ss">f'</span><span class="sc">{</span>vmg_positive_pct<span class="sc">:.2%}</span><span class="ss">'</span>]</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"VMG因子基本统计指标："</span>)</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(stats_df)</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 3. 可视化分析 ---</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a><span class="co"># 绘制VMG因子的累积收益曲线</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>vmg_returns[<span class="st">'VMG_cumulative'</span>] <span class="op">=</span> (<span class="dv">1</span> <span class="op">+</span> vmg_returns[<span class="st">'VMG'</span>]).cumprod() <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>plt.plot(vmg_returns.index, vmg_returns[<span class="st">'VMG_cumulative'</span>], <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>plt.axhline(y<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'VMG因子累积收益 (2010-2022)'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'日期'</span>)</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'累积收益率'</span>)</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a><span class="co"># plt.show()  # 实际使用时取消注释</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 4. 市场环境分析 ---</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a><span class="co"># 假设我们有中证500指数同期的月度收益率数据</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>market_data <span class="op">=</span> {</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>    <span class="st">'ym'</span>: vmg_returns.index,</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>    <span class="st">'Market'</span>: np.random.normal(<span class="fl">0.007</span>, <span class="fl">0.06</span>, <span class="dv">156</span>)  <span class="co"># 模拟市场收益</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>market_returns <span class="op">=</span> pd.DataFrame(market_data)</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>market_returns.set_index(<span class="st">'ym'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a><span class="co"># 将市场划分为牛市和熊市（简单地用正负收益区分）</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>market_returns[<span class="st">'Market_State'</span>] <span class="op">=</span> market_returns[<span class="st">'Market'</span>].<span class="bu">apply</span>(</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>    <span class="kw">lambda</span> x: <span class="st">'牛市'</span> <span class="cf">if</span> x <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="st">'熊市'</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a><span class="co"># 合并数据</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>combined_df <span class="op">=</span> pd.concat([vmg_returns[<span class="st">'VMG'</span>], market_returns[<span class="st">'Market_State'</span>]], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a><span class="co"># 计算不同市场状态下VMG因子的表现</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>market_state_analysis <span class="op">=</span> combined_df.groupby(<span class="st">'Market_State'</span>)[<span class="st">'VMG'</span>].agg(</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>    [<span class="st">'mean'</span>, <span class="st">'std'</span>, <span class="st">'count'</span>]</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>).rename(columns<span class="op">=</span>{<span class="st">'mean'</span>: <span class="st">'平均收益率'</span>, <span class="st">'std'</span>: <span class="st">'标准差'</span>, <span class="st">'count'</span>: <span class="st">'月份数'</span>})</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>market_state_analysis[<span class="st">'t值'</span>] <span class="op">=</span> market_state_analysis[<span class="st">'平均收益率'</span>] <span class="op">/</span> (</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>    market_state_analysis[<span class="st">'标准差'</span>] <span class="op">/</span> np.sqrt(market_state_analysis[<span class="st">'月份数'</span>])</span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">VMG因子在不同市场环境下的表现："</span>)</span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(market_state_analysis)</span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 5. 稳定性分析：滚动IC值 ---</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a><span class="co"># 假设我们计算了EP与下个月股票收益的截面相关系数(IC)</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a><span class="co"># 为简化示例，这里我们使用模拟数据</span></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>rolling_months <span class="op">=</span> <span class="dv">12</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>ic_data <span class="op">=</span> {</span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>    <span class="st">'ym'</span>: vmg_returns.index,</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>    <span class="st">'IC'</span>: np.random.normal(<span class="fl">0.04</span>, <span class="fl">0.15</span>, <span class="dv">156</span>)  <span class="co"># 模拟IC值序列</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>ic_df <span class="op">=</span> pd.DataFrame(ic_data)</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>ic_df.set_index(<span class="st">'ym'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a><span class="co"># 计算滚动IC均值和IC IR (信息比率)</span></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>ic_df[<span class="st">'Rolling_Mean'</span>] <span class="op">=</span> ic_df[<span class="st">'IC'</span>].rolling(rolling_months).mean()</span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>ic_df[<span class="st">'Rolling_Std'</span>] <span class="op">=</span> ic_df[<span class="st">'IC'</span>].rolling(rolling_months).std()</span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>ic_df[<span class="st">'Rolling_IR'</span>] <span class="op">=</span> ic_df[<span class="st">'Rolling_Mean'</span>] <span class="op">/</span> ic_df[<span class="st">'Rolling_Std'</span>]</span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a><span class="co"># 计算IC的整体统计量</span></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>ic_mean <span class="op">=</span> ic_df[<span class="st">'IC'</span>].mean()</span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>ic_std <span class="op">=</span> ic_df[<span class="st">'IC'</span>].std()</span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>ic_ir <span class="op">=</span> ic_mean <span class="op">/</span> ic_std</span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>ic_positive_pct <span class="op">=</span> (ic_df[<span class="st">'IC'</span>] <span class="op">&gt;</span> <span class="dv">0</span>).mean()</span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>ic_stats <span class="op">=</span> pd.DataFrame({</span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>    <span class="st">'指标'</span>: [<span class="st">'IC均值'</span>, <span class="st">'IC标准差'</span>, <span class="st">'IR值'</span>, <span class="st">'IC&gt;0比例'</span>],</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a>    <span class="st">'数值'</span>: [<span class="ss">f'</span><span class="sc">{</span>ic_mean<span class="sc">:.2%}</span><span class="ss">'</span>, <span class="ss">f'</span><span class="sc">{</span>ic_std<span class="sc">:.2%}</span><span class="ss">'</span>, <span class="ss">f'</span><span class="sc">{</span>ic_ir<span class="sc">:.2f}</span><span class="ss">'</span>, <span class="ss">f'</span><span class="sc">{</span>ic_positive_pct<span class="sc">:.2%}</span><span class="ss">'</span>]</span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">EP因子IC统计指标："</span>)</span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ic_stats)</span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 6. 行业分析 ---</span></span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a><span class="co"># 假设我们有按行业分类的EP和收益数据</span></span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a><span class="co"># 这里使用模拟数据展示行业间的EP效应差异</span></span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a>industries <span class="op">=</span> [<span class="st">'消费'</span>, <span class="st">'医疗'</span>, <span class="st">'金融'</span>, <span class="st">'科技'</span>, <span class="st">'能源'</span>, <span class="st">'原材料'</span>, <span class="st">'工业'</span>, <span class="st">'公用事业'</span>, <span class="st">'房地产'</span>, <span class="st">'通信'</span>]</span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>industry_data <span class="op">=</span> []</span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> industry <span class="kw">in</span> industries:</span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 模拟该行业的IC值和t统计量</span></span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a>    ic_value <span class="op">=</span> np.random.normal(<span class="fl">0.04</span>, <span class="fl">0.02</span>)</span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a>    t_value <span class="op">=</span> np.random.normal(<span class="fl">2.0</span>, <span class="fl">0.5</span>)</span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a>    industry_data.append([industry, ic_value, t_value])</span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a>industry_df <span class="op">=</span> pd.DataFrame(industry_data, columns<span class="op">=</span>[<span class="st">'行业'</span>, <span class="st">'IC值'</span>, <span class="st">'t统计量'</span>])</span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">不同行业的EP因子IC值："</span>)</span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(industry_df)</span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a><span class="co"># 绘制不同行业的IC值对比图</span></span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a>plt.bar(industry_df[<span class="st">'行业'</span>], industry_df[<span class="st">'IC值'</span>], color<span class="op">=</span><span class="st">'skyblue'</span>)</span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a>plt.axhline(y<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'EP因子在不同行业的IC值'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'行业'</span>)</span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'IC值'</span>)</span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a>plt.xticks(rotation<span class="op">=</span><span class="dv">45</span>)</span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a><span class="co"># plt.show()  # 实际使用时取消注释</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>分析结果解读</strong>：</p>
<p>从上述分析中，我们可以得出关于VMG因子在中国市场的几个关键发现：</p>
<ol type="1">
<li><p><strong>长期有效性</strong>：VMG因子月度平均收益为0.5%，t值为2.86 (&gt;2)，表明VMG因子在中国A股市场长期有统计显著的正收益。</p></li>
<li><p><strong>市场环境依赖性</strong>：VMG因子在熊市中的表现(0.83%)明显优于牛市(0.23%)，这与价值股在市场下跌时通常具有更好防御性的理论一致。</p></li>
<li><p><strong>信息系数(IC)表现</strong>：EP因子的平均IC为0.04，虽然看起来不高，但在单因子中属于较好水平，IC&gt;0的比例为58%，表明EP因子具有一定的预测能力。</p></li>
<li><p><strong>行业差异</strong>：EP因子在传统行业（如能源、原材料）的IC值明显高于新兴行业（如科技、医疗），这符合价值因子的行业偏好特征。</p></li>
<li><p><strong>稳定性</strong>：通过滚动分析可看出，EP因子的IC值和VMG收益均存在波动，并非在所有时期都有效，这提示我们可能需要考虑因子择时或多因子组合。</p></li>
</ol>
<p>这些分析为我们后续进行EP因子增强提供了方向：行业中性化处理、与质量因子结合以提高在成长行业的有效性、以及考虑市场环境进行动态调整等。</p>
</section>
</section>
<section id="因子优缺点与可投资性-investability" class="level3" data-number="9.3.3">
<h3 data-number="9.3.3" class="anchored" data-anchor-id="因子优缺点与可投资性-investability"><span class="header-section-number">9.3.3</span> 1.3 因子优缺点与可投资性 (Investability)</h3>
<ul>
<li><strong>优点</strong>: 逻辑直观、计算相对简单、数据可得性好、多市场有效。</li>
<li><strong>缺点</strong>: 盈利波动与会计操纵风险、价值陷阱风险、行业偏见、负盈利处理问题。</li>
<li><strong>可投资性 (Investability):</strong> 换手率中等、交易成本需考虑、策略容量通常较大。</li>
</ul>
<hr>
</section>
</section>
<section id="part-2-ep-因子增强策略" class="level2" data-number="9.4">
<h2 data-number="9.4" class="anchored" data-anchor-id="part-2-ep-因子增强策略"><span class="header-section-number">9.4</span> Part 2: EP 因子增强策略</h2>
<p>基于对 EP 因子的理解和理论知识，我们可以尝试以下几种增强方法：</p>
<section id="增强-1-考虑行业差异-industry-adjustment" class="level3" data-number="9.4.1">
<h3 data-number="9.4.1" class="anchored" data-anchor-id="增强-1-考虑行业差异-industry-adjustment"><span class="header-section-number">9.4.1</span> 增强 1: 考虑行业差异 (Industry Adjustment)</h3>
<ul>
<li><strong>方法</strong>: 计算行业中性化的 EP (如行业内 Z-Score) 或进行行业内排序。</li>
<li><strong>效果</strong>: 消除行业估值差异，捕捉行业内相对价值，降低组合行业风险暴露。</li>
</ul>
<section id="增强1实践行业中性化ep因子构建与回测" class="level4" data-number="9.4.1.1">
<h4 data-number="9.4.1.1" class="anchored" data-anchor-id="增强1实践行业中性化ep因子构建与回测"><span class="header-section-number">9.4.1.1</span> 增强1实践：行业中性化EP因子构建与回测</h4>
<p>以下代码展示了如何构建行业中性的EP因子，并与原始EP因子进行对比分析：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> stats</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 1. 数据准备 ---</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 这里使用模拟数据，实际应用中应使用真实股票数据</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 假设有100只股票，10个行业，10年月度数据</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 生成模拟数据框架</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>stocks <span class="op">=</span> [<span class="ss">f'股票</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">101</span>)]</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>industries <span class="op">=</span> [<span class="st">'消费'</span>, <span class="st">'医疗'</span>, <span class="st">'金融'</span>, <span class="st">'科技'</span>, <span class="st">'能源'</span>, <span class="st">'原材料'</span>, <span class="st">'工业'</span>, <span class="st">'公用事业'</span>, <span class="st">'房地产'</span>, <span class="st">'通信'</span>]</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>dates <span class="op">=</span> pd.date_range(start<span class="op">=</span><span class="st">'2013-01-31'</span>, end<span class="op">=</span><span class="st">'2022-12-31'</span>, freq<span class="op">=</span><span class="st">'M'</span>)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co"># 将股票分配到行业</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>stock_industry <span class="op">=</span> {}</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> stock <span class="kw">in</span> stocks:</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    stock_industry[stock] <span class="op">=</span> np.random.choice(industries)</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="co"># 创建空的数据框</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>columns <span class="op">=</span> [<span class="st">'date'</span>, <span class="st">'stock'</span>, <span class="st">'industry'</span>, <span class="st">'ep'</span>, <span class="st">'size'</span>, <span class="st">'return_next_month'</span>]</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> []</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="co"># 为每个股票在每个日期生成数据</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a><span class="co"># 注意：我们让每个行业有不同的平均EP水平，以模拟现实中的行业差异</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>industry_ep_means <span class="op">=</span> {</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    <span class="st">'消费'</span>: <span class="fl">0.04</span>, <span class="st">'医疗'</span>: <span class="fl">0.03</span>, <span class="st">'金融'</span>: <span class="fl">0.08</span>, <span class="st">'科技'</span>: <span class="fl">0.02</span>, </span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    <span class="st">'能源'</span>: <span class="fl">0.09</span>, <span class="st">'原材料'</span>: <span class="fl">0.07</span>, <span class="st">'工业'</span>: <span class="fl">0.06</span>, </span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    <span class="st">'公用事业'</span>: <span class="fl">0.05</span>, <span class="st">'房地产'</span>: <span class="fl">0.10</span>, <span class="st">'通信'</span>: <span class="fl">0.03</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> date <span class="kw">in</span> dates:</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> stock <span class="kw">in</span> stocks:</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>        industry <span class="op">=</span> stock_industry[stock]</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 生成EP值（围绕行业均值）</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>        ep <span class="op">=</span> np.random.normal(industry_ep_means[industry], <span class="fl">0.02</span>)</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 生成市值（对数正态分布）</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>        size <span class="op">=</span> np.exp(np.random.normal(<span class="dv">10</span>, <span class="dv">1</span>))</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 生成下月收益（部分受EP影响，模拟EP因子对收益的预测能力）</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 加入行业效应和随机噪声</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>        industry_effect <span class="op">=</span> <span class="fl">0.002</span> <span class="cf">if</span> industry <span class="kw">in</span> [<span class="st">'科技'</span>, <span class="st">'医疗'</span>] <span class="cf">else</span> <span class="op">-</span><span class="fl">0.001</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>        return_next <span class="op">=</span> <span class="fl">0.002</span> <span class="op">+</span> <span class="fl">0.1</span> <span class="op">*</span> ep <span class="op">+</span> industry_effect <span class="op">+</span> np.random.normal(<span class="dv">0</span>, <span class="fl">0.05</span>)</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>        data.append([date, stock, industry, ep, size, return_next])</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a><span class="co"># 创建DataFrame</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(data, columns<span class="op">=</span>columns)</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 2. 计算原始EP因子和行业中性EP ---</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_factors(data, date):</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""为特定日期计算原始EP和行业中性EP因子值"""</span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 选择该日期的数据</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>    df_date <span class="op">=</span> data[data[<span class="st">'date'</span>] <span class="op">==</span> date].copy()</span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 处理极端值（简单缩尾）</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>    df_date[<span class="st">'ep'</span>] <span class="op">=</span> np.clip(df_date[<span class="st">'ep'</span>], </span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>                          df_date[<span class="st">'ep'</span>].quantile(<span class="fl">0.01</span>), </span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>                          df_date[<span class="st">'ep'</span>].quantile(<span class="fl">0.99</span>))</span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 计算原始EP的截面Z-Score</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>    df_date[<span class="st">'ep_zscore'</span>] <span class="op">=</span> stats.zscore(df_date[<span class="st">'ep'</span>])</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 计算行业中性EP</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>    industry_adj_ep <span class="op">=</span> []</span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ind <span class="kw">in</span> df_date[<span class="st">'industry'</span>].unique():</span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>        ind_data <span class="op">=</span> df_date[df_date[<span class="st">'industry'</span>] <span class="op">==</span> ind]</span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(ind_data) <span class="op">&gt;</span> <span class="dv">1</span>:  <span class="co"># 确保行业内有足够的股票</span></span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>            ind_mean <span class="op">=</span> ind_data[<span class="st">'ep'</span>].mean()</span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>            ind_std <span class="op">=</span> ind_data[<span class="st">'ep'</span>].std()</span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 计算行业内z-score</span></span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> _, row <span class="kw">in</span> ind_data.iterrows():</span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> ind_std <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a>                    z_score <span class="op">=</span> (row[<span class="st">'ep'</span>] <span class="op">-</span> ind_mean) <span class="op">/</span> ind_std</span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a>                    z_score <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a>                industry_adj_ep.append([row[<span class="st">'stock'</span>], z_score])</span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 转换为DataFrame并与主数据合并</span></span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a>    ind_adj_df <span class="op">=</span> pd.DataFrame(industry_adj_ep, columns<span class="op">=</span>[<span class="st">'stock'</span>, <span class="st">'ep_ind_adj'</span>])</span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a>    df_merged <span class="op">=</span> pd.merge(df_date, ind_adj_df, on<span class="op">=</span><span class="st">'stock'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df_merged</span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a><span class="co"># 对每个日期计算因子</span></span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a>processed_data <span class="op">=</span> pd.DataFrame()</span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> date <span class="kw">in</span> dates:</span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a>    processed_data <span class="op">=</span> pd.concat([processed_data, calculate_factors(df, date)])</span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 3. 构建投资组合并回测 ---</span></span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backtest_factor(data, factor_name, n_groups<span class="op">=</span><span class="dv">5</span>, weighted_by<span class="op">=</span><span class="st">'equal'</span>):</span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-94"><a href="#cb2-94" aria-hidden="true" tabindex="-1"></a><span class="co">    对因子进行分组回测</span></span>
<span id="cb2-95"><a href="#cb2-95" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb2-96"><a href="#cb2-96" aria-hidden="true" tabindex="-1"></a><span class="co">    参数:</span></span>
<span id="cb2-97"><a href="#cb2-97" aria-hidden="true" tabindex="-1"></a><span class="co">    - data: 包含因子值和下月收益的DataFrame</span></span>
<span id="cb2-98"><a href="#cb2-98" aria-hidden="true" tabindex="-1"></a><span class="co">    - factor_name: 因子列名</span></span>
<span id="cb2-99"><a href="#cb2-99" aria-hidden="true" tabindex="-1"></a><span class="co">    - n_groups: 分组数量</span></span>
<span id="cb2-100"><a href="#cb2-100" aria-hidden="true" tabindex="-1"></a><span class="co">    - weighted_by: 'equal'为等权重，'size'为市值加权</span></span>
<span id="cb2-101"><a href="#cb2-101" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb2-102"><a href="#cb2-102" aria-hidden="true" tabindex="-1"></a><span class="co">    返回:</span></span>
<span id="cb2-103"><a href="#cb2-103" aria-hidden="true" tabindex="-1"></a><span class="co">    - 各分组的月度收益序列</span></span>
<span id="cb2-104"><a href="#cb2-104" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-105"><a href="#cb2-105" aria-hidden="true" tabindex="-1"></a>    portfolio_returns <span class="op">=</span> {}</span>
<span id="cb2-106"><a href="#cb2-106" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-107"><a href="#cb2-107" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 初始化各分组的收益序列字典</span></span>
<span id="cb2-108"><a href="#cb2-108" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n_groups <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-109"><a href="#cb2-109" aria-hidden="true" tabindex="-1"></a>        portfolio_returns[<span class="ss">f'G</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span>] <span class="op">=</span> []</span>
<span id="cb2-110"><a href="#cb2-110" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-111"><a href="#cb2-111" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 添加多空组合</span></span>
<span id="cb2-112"><a href="#cb2-112" aria-hidden="true" tabindex="-1"></a>    portfolio_returns[<span class="st">'Long_Short'</span>] <span class="op">=</span> []</span>
<span id="cb2-113"><a href="#cb2-113" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-114"><a href="#cb2-114" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 按日期循环</span></span>
<span id="cb2-115"><a href="#cb2-115" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> date <span class="kw">in</span> dates:</span>
<span id="cb2-116"><a href="#cb2-116" aria-hidden="true" tabindex="-1"></a>        date_data <span class="op">=</span> data[data[<span class="st">'date'</span>] <span class="op">==</span> date].copy()</span>
<span id="cb2-117"><a href="#cb2-117" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-118"><a href="#cb2-118" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 确保有足够的数据</span></span>
<span id="cb2-119"><a href="#cb2-119" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(date_data) <span class="op">&lt;</span> n_groups:</span>
<span id="cb2-120"><a href="#cb2-120" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb2-121"><a href="#cb2-121" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-122"><a href="#cb2-122" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 按因子值分组</span></span>
<span id="cb2-123"><a href="#cb2-123" aria-hidden="true" tabindex="-1"></a>        date_data[<span class="st">'group'</span>] <span class="op">=</span> pd.qcut(date_data[factor_name], </span>
<span id="cb2-124"><a href="#cb2-124" aria-hidden="true" tabindex="-1"></a>                                   q<span class="op">=</span>n_groups, </span>
<span id="cb2-125"><a href="#cb2-125" aria-hidden="true" tabindex="-1"></a>                                   labels<span class="op">=</span>[<span class="ss">f'G</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n_groups <span class="op">+</span> <span class="dv">1</span>)])</span>
<span id="cb2-126"><a href="#cb2-126" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-127"><a href="#cb2-127" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 计算各分组的下月收益</span></span>
<span id="cb2-128"><a href="#cb2-128" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> group <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n_groups <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-129"><a href="#cb2-129" aria-hidden="true" tabindex="-1"></a>            group_data <span class="op">=</span> date_data[date_data[<span class="st">'group'</span>] <span class="op">==</span> <span class="ss">f'G</span><span class="sc">{</span>group<span class="sc">}</span><span class="ss">'</span>]</span>
<span id="cb2-130"><a href="#cb2-130" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb2-131"><a href="#cb2-131" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(group_data) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb2-132"><a href="#cb2-132" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb2-133"><a href="#cb2-133" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb2-134"><a href="#cb2-134" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> weighted_by <span class="op">==</span> <span class="st">'equal'</span>:</span>
<span id="cb2-135"><a href="#cb2-135" aria-hidden="true" tabindex="-1"></a>                <span class="co"># 等权重</span></span>
<span id="cb2-136"><a href="#cb2-136" aria-hidden="true" tabindex="-1"></a>                group_return <span class="op">=</span> group_data[<span class="st">'return_next_month'</span>].mean()</span>
<span id="cb2-137"><a href="#cb2-137" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb2-138"><a href="#cb2-138" aria-hidden="true" tabindex="-1"></a>                <span class="co"># 市值加权</span></span>
<span id="cb2-139"><a href="#cb2-139" aria-hidden="true" tabindex="-1"></a>                weights <span class="op">=</span> group_data[<span class="st">'size'</span>] <span class="op">/</span> group_data[<span class="st">'size'</span>].<span class="bu">sum</span>()</span>
<span id="cb2-140"><a href="#cb2-140" aria-hidden="true" tabindex="-1"></a>                group_return <span class="op">=</span> (group_data[<span class="st">'return_next_month'</span>] <span class="op">*</span> weights).<span class="bu">sum</span>()</span>
<span id="cb2-141"><a href="#cb2-141" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb2-142"><a href="#cb2-142" aria-hidden="true" tabindex="-1"></a>            portfolio_returns[<span class="ss">f'G</span><span class="sc">{</span>group<span class="sc">}</span><span class="ss">'</span>].append(group_return)</span>
<span id="cb2-143"><a href="#cb2-143" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-144"><a href="#cb2-144" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 计算多空组合收益（做多最高分组，做空最低分组）</span></span>
<span id="cb2-145"><a href="#cb2-145" aria-hidden="true" tabindex="-1"></a>        high_group_data <span class="op">=</span> date_data[date_data[<span class="st">'group'</span>] <span class="op">==</span> <span class="ss">f'G</span><span class="sc">{</span>n_groups<span class="sc">}</span><span class="ss">'</span>]</span>
<span id="cb2-146"><a href="#cb2-146" aria-hidden="true" tabindex="-1"></a>        low_group_data <span class="op">=</span> date_data[date_data[<span class="st">'group'</span>] <span class="op">==</span> <span class="ss">f'G1'</span>]</span>
<span id="cb2-147"><a href="#cb2-147" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-148"><a href="#cb2-148" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(high_group_data) <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> <span class="bu">len</span>(low_group_data) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb2-149"><a href="#cb2-149" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> weighted_by <span class="op">==</span> <span class="st">'equal'</span>:</span>
<span id="cb2-150"><a href="#cb2-150" aria-hidden="true" tabindex="-1"></a>                high_return <span class="op">=</span> high_group_data[<span class="st">'return_next_month'</span>].mean()</span>
<span id="cb2-151"><a href="#cb2-151" aria-hidden="true" tabindex="-1"></a>                low_return <span class="op">=</span> low_group_data[<span class="st">'return_next_month'</span>].mean()</span>
<span id="cb2-152"><a href="#cb2-152" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb2-153"><a href="#cb2-153" aria-hidden="true" tabindex="-1"></a>                high_weights <span class="op">=</span> high_group_data[<span class="st">'size'</span>] <span class="op">/</span> high_group_data[<span class="st">'size'</span>].<span class="bu">sum</span>()</span>
<span id="cb2-154"><a href="#cb2-154" aria-hidden="true" tabindex="-1"></a>                low_weights <span class="op">=</span> low_group_data[<span class="st">'size'</span>] <span class="op">/</span> low_group_data[<span class="st">'size'</span>].<span class="bu">sum</span>()</span>
<span id="cb2-155"><a href="#cb2-155" aria-hidden="true" tabindex="-1"></a>                high_return <span class="op">=</span> (high_group_data[<span class="st">'return_next_month'</span>] <span class="op">*</span> high_weights).<span class="bu">sum</span>()</span>
<span id="cb2-156"><a href="#cb2-156" aria-hidden="true" tabindex="-1"></a>                low_return <span class="op">=</span> (low_group_data[<span class="st">'return_next_month'</span>] <span class="op">*</span> low_weights).<span class="bu">sum</span>()</span>
<span id="cb2-157"><a href="#cb2-157" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb2-158"><a href="#cb2-158" aria-hidden="true" tabindex="-1"></a>            long_short_return <span class="op">=</span> high_return <span class="op">-</span> low_return</span>
<span id="cb2-159"><a href="#cb2-159" aria-hidden="true" tabindex="-1"></a>            portfolio_returns[<span class="st">'Long_Short'</span>].append(long_short_return)</span>
<span id="cb2-160"><a href="#cb2-160" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-161"><a href="#cb2-161" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 转换为DataFrame</span></span>
<span id="cb2-162"><a href="#cb2-162" aria-hidden="true" tabindex="-1"></a>    portfolio_returns_df <span class="op">=</span> pd.DataFrame(portfolio_returns)</span>
<span id="cb2-163"><a href="#cb2-163" aria-hidden="true" tabindex="-1"></a>    portfolio_returns_df.index <span class="op">=</span> dates[:<span class="bu">len</span>(portfolio_returns_df)]</span>
<span id="cb2-164"><a href="#cb2-164" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-165"><a href="#cb2-165" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> portfolio_returns_df</span>
<span id="cb2-166"><a href="#cb2-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-167"><a href="#cb2-167" aria-hidden="true" tabindex="-1"></a><span class="co"># 回测原始EP和行业中性EP</span></span>
<span id="cb2-168"><a href="#cb2-168" aria-hidden="true" tabindex="-1"></a>original_ep_returns <span class="op">=</span> backtest_factor(processed_data, <span class="st">'ep_zscore'</span>, n_groups<span class="op">=</span><span class="dv">5</span>, weighted_by<span class="op">=</span><span class="st">'size'</span>)</span>
<span id="cb2-169"><a href="#cb2-169" aria-hidden="true" tabindex="-1"></a>industry_adj_ep_returns <span class="op">=</span> backtest_factor(processed_data, <span class="st">'ep_ind_adj'</span>, n_groups<span class="op">=</span><span class="dv">5</span>, weighted_by<span class="op">=</span><span class="st">'size'</span>)</span>
<span id="cb2-170"><a href="#cb2-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-171"><a href="#cb2-171" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 4. 性能评估与对比 ---</span></span>
<span id="cb2-172"><a href="#cb2-172" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate_performance(returns_df):</span>
<span id="cb2-173"><a href="#cb2-173" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""计算投资组合的性能指标"""</span></span>
<span id="cb2-174"><a href="#cb2-174" aria-hidden="true" tabindex="-1"></a>    performance <span class="op">=</span> {}</span>
<span id="cb2-175"><a href="#cb2-175" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-176"><a href="#cb2-176" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> column <span class="kw">in</span> returns_df.columns:</span>
<span id="cb2-177"><a href="#cb2-177" aria-hidden="true" tabindex="-1"></a>        returns <span class="op">=</span> returns_df[column]</span>
<span id="cb2-178"><a href="#cb2-178" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-179"><a href="#cb2-179" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 月度平均收益</span></span>
<span id="cb2-180"><a href="#cb2-180" aria-hidden="true" tabindex="-1"></a>        monthly_return <span class="op">=</span> returns.mean()</span>
<span id="cb2-181"><a href="#cb2-181" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-182"><a href="#cb2-182" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 月度波动率</span></span>
<span id="cb2-183"><a href="#cb2-183" aria-hidden="true" tabindex="-1"></a>        monthly_vol <span class="op">=</span> returns.std()</span>
<span id="cb2-184"><a href="#cb2-184" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-185"><a href="#cb2-185" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 夏普比率（假设无风险利率为0）</span></span>
<span id="cb2-186"><a href="#cb2-186" aria-hidden="true" tabindex="-1"></a>        sharpe <span class="op">=</span> monthly_return <span class="op">/</span> monthly_vol <span class="cf">if</span> monthly_vol <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb2-187"><a href="#cb2-187" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-188"><a href="#cb2-188" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 年化指标</span></span>
<span id="cb2-189"><a href="#cb2-189" aria-hidden="true" tabindex="-1"></a>        annual_return <span class="op">=</span> (<span class="dv">1</span> <span class="op">+</span> monthly_return) <span class="op">**</span> <span class="dv">12</span> <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb2-190"><a href="#cb2-190" aria-hidden="true" tabindex="-1"></a>        annual_vol <span class="op">=</span> monthly_vol <span class="op">*</span> np.sqrt(<span class="dv">12</span>)</span>
<span id="cb2-191"><a href="#cb2-191" aria-hidden="true" tabindex="-1"></a>        annual_sharpe <span class="op">=</span> sharpe <span class="op">*</span> np.sqrt(<span class="dv">12</span>)</span>
<span id="cb2-192"><a href="#cb2-192" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-193"><a href="#cb2-193" aria-hidden="true" tabindex="-1"></a>        <span class="co"># t值</span></span>
<span id="cb2-194"><a href="#cb2-194" aria-hidden="true" tabindex="-1"></a>        t_stat <span class="op">=</span> monthly_return <span class="op">/</span> (monthly_vol <span class="op">/</span> np.sqrt(<span class="bu">len</span>(returns)))</span>
<span id="cb2-195"><a href="#cb2-195" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-196"><a href="#cb2-196" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 胜率（正收益月份比例）</span></span>
<span id="cb2-197"><a href="#cb2-197" aria-hidden="true" tabindex="-1"></a>        win_rate <span class="op">=</span> (returns <span class="op">&gt;</span> <span class="dv">0</span>).mean()</span>
<span id="cb2-198"><a href="#cb2-198" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-199"><a href="#cb2-199" aria-hidden="true" tabindex="-1"></a>        performance[column] <span class="op">=</span> {</span>
<span id="cb2-200"><a href="#cb2-200" aria-hidden="true" tabindex="-1"></a>            <span class="st">'月均收益'</span>: monthly_return,</span>
<span id="cb2-201"><a href="#cb2-201" aria-hidden="true" tabindex="-1"></a>            <span class="st">'月度波动率'</span>: monthly_vol,</span>
<span id="cb2-202"><a href="#cb2-202" aria-hidden="true" tabindex="-1"></a>            <span class="st">'夏普比率'</span>: sharpe,</span>
<span id="cb2-203"><a href="#cb2-203" aria-hidden="true" tabindex="-1"></a>            <span class="st">'年化收益'</span>: annual_return,</span>
<span id="cb2-204"><a href="#cb2-204" aria-hidden="true" tabindex="-1"></a>            <span class="st">'年化波动率'</span>: annual_vol,</span>
<span id="cb2-205"><a href="#cb2-205" aria-hidden="true" tabindex="-1"></a>            <span class="st">'年化夏普'</span>: annual_sharpe,</span>
<span id="cb2-206"><a href="#cb2-206" aria-hidden="true" tabindex="-1"></a>            <span class="st">'t统计量'</span>: t_stat,</span>
<span id="cb2-207"><a href="#cb2-207" aria-hidden="true" tabindex="-1"></a>            <span class="st">'胜率'</span>: win_rate</span>
<span id="cb2-208"><a href="#cb2-208" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb2-209"><a href="#cb2-209" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-210"><a href="#cb2-210" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pd.DataFrame(performance).T</span>
<span id="cb2-211"><a href="#cb2-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-212"><a href="#cb2-212" aria-hidden="true" tabindex="-1"></a><span class="co"># 评估原始EP和行业中性EP的表现</span></span>
<span id="cb2-213"><a href="#cb2-213" aria-hidden="true" tabindex="-1"></a>original_performance <span class="op">=</span> evaluate_performance(original_ep_returns)</span>
<span id="cb2-214"><a href="#cb2-214" aria-hidden="true" tabindex="-1"></a>industry_adj_performance <span class="op">=</span> evaluate_performance(industry_adj_ep_returns)</span>
<span id="cb2-215"><a href="#cb2-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-216"><a href="#cb2-216" aria-hidden="true" tabindex="-1"></a><span class="co"># 打印多空组合的性能对比</span></span>
<span id="cb2-217"><a href="#cb2-217" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"原始EP因子多空组合性能："</span>)</span>
<span id="cb2-218"><a href="#cb2-218" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(original_performance.loc[<span class="st">'Long_Short'</span>, [<span class="st">'年化收益'</span>, <span class="st">'年化波动率'</span>, <span class="st">'年化夏普'</span>, <span class="st">'t统计量'</span>, <span class="st">'胜率'</span>]])</span>
<span id="cb2-219"><a href="#cb2-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-220"><a href="#cb2-220" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">行业中性EP因子多空组合性能："</span>)</span>
<span id="cb2-221"><a href="#cb2-221" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(industry_adj_performance.loc[<span class="st">'Long_Short'</span>, [<span class="st">'年化收益'</span>, <span class="st">'年化波动率'</span>, <span class="st">'年化夏普'</span>, <span class="st">'t统计量'</span>, <span class="st">'胜率'</span>]])</span>
<span id="cb2-222"><a href="#cb2-222" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-223"><a href="#cb2-223" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 5. 可视化比较 ---</span></span>
<span id="cb2-224"><a href="#cb2-224" aria-hidden="true" tabindex="-1"></a><span class="co"># 绘制累积收益曲线</span></span>
<span id="cb2-225"><a href="#cb2-225" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_cumulative_returns(returns_df1, returns_df2, title1, title2):</span>
<span id="cb2-226"><a href="#cb2-226" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""绘制两个投资组合的累积收益对比图"""</span></span>
<span id="cb2-227"><a href="#cb2-227" aria-hidden="true" tabindex="-1"></a>    cum_returns1 <span class="op">=</span> (<span class="dv">1</span> <span class="op">+</span> returns_df1[<span class="st">'Long_Short'</span>]).cumprod() <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb2-228"><a href="#cb2-228" aria-hidden="true" tabindex="-1"></a>    cum_returns2 <span class="op">=</span> (<span class="dv">1</span> <span class="op">+</span> returns_df2[<span class="st">'Long_Short'</span>]).cumprod() <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb2-229"><a href="#cb2-229" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-230"><a href="#cb2-230" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb2-231"><a href="#cb2-231" aria-hidden="true" tabindex="-1"></a>    plt.plot(cum_returns1.index, cum_returns1.values, <span class="st">'b-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span>title1)</span>
<span id="cb2-232"><a href="#cb2-232" aria-hidden="true" tabindex="-1"></a>    plt.plot(cum_returns2.index, cum_returns2.values, <span class="st">'r-'</span>, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span>title2)</span>
<span id="cb2-233"><a href="#cb2-233" aria-hidden="true" tabindex="-1"></a>    plt.axhline(y<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'gray'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb2-234"><a href="#cb2-234" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">'累积收益对比 (2013-2022)'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb2-235"><a href="#cb2-235" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'日期'</span>)</span>
<span id="cb2-236"><a href="#cb2-236" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'累积收益率'</span>)</span>
<span id="cb2-237"><a href="#cb2-237" aria-hidden="true" tabindex="-1"></a>    plt.legend()</span>
<span id="cb2-238"><a href="#cb2-238" aria-hidden="true" tabindex="-1"></a>    plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb2-239"><a href="#cb2-239" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb2-240"><a href="#cb2-240" aria-hidden="true" tabindex="-1"></a>    <span class="co"># plt.show()  # 实际使用时取消注释</span></span>
<span id="cb2-241"><a href="#cb2-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-242"><a href="#cb2-242" aria-hidden="true" tabindex="-1"></a><span class="co"># 绘制收益对比图</span></span>
<span id="cb2-243"><a href="#cb2-243" aria-hidden="true" tabindex="-1"></a><span class="co"># plot_cumulative_returns(original_ep_returns, industry_adj_ep_returns, </span></span>
<span id="cb2-244"><a href="#cb2-244" aria-hidden="true" tabindex="-1"></a><span class="co">#                        "原始EP因子多空组合", "行业中性EP因子多空组合")</span></span>
<span id="cb2-245"><a href="#cb2-245" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-246"><a href="#cb2-246" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 6. 行业暴露分析 ---</span></span>
<span id="cb2-247"><a href="#cb2-247" aria-hidden="true" tabindex="-1"></a><span class="co"># 分析两种策略的行业暴露差异</span></span>
<span id="cb2-248"><a href="#cb2-248" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> analyze_industry_exposure(data, factor1, factor2, top_pct<span class="op">=</span><span class="fl">0.2</span>):</span>
<span id="cb2-249"><a href="#cb2-249" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""分析两个因子的行业暴露差异"""</span></span>
<span id="cb2-250"><a href="#cb2-250" aria-hidden="true" tabindex="-1"></a>    industry_exposure <span class="op">=</span> {}</span>
<span id="cb2-251"><a href="#cb2-251" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-252"><a href="#cb2-252" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> date <span class="kw">in</span> dates:</span>
<span id="cb2-253"><a href="#cb2-253" aria-hidden="true" tabindex="-1"></a>        date_data <span class="op">=</span> data[data[<span class="st">'date'</span>] <span class="op">==</span> date].copy()</span>
<span id="cb2-254"><a href="#cb2-254" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-255"><a href="#cb2-255" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 计算每个行业在全市场中的权重</span></span>
<span id="cb2-256"><a href="#cb2-256" aria-hidden="true" tabindex="-1"></a>        market_industry_weights <span class="op">=</span> date_data.groupby(<span class="st">'industry'</span>)[<span class="st">'size'</span>].<span class="bu">sum</span>() <span class="op">/</span> date_data[<span class="st">'size'</span>].<span class="bu">sum</span>()</span>
<span id="cb2-257"><a href="#cb2-257" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-258"><a href="#cb2-258" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 获取因子值最高的前20%股票</span></span>
<span id="cb2-259"><a href="#cb2-259" aria-hidden="true" tabindex="-1"></a>        factor1_top <span class="op">=</span> date_data.nlargest(<span class="bu">int</span>(<span class="bu">len</span>(date_data) <span class="op">*</span> top_pct), factor1)</span>
<span id="cb2-260"><a href="#cb2-260" aria-hidden="true" tabindex="-1"></a>        factor2_top <span class="op">=</span> date_data.nlargest(<span class="bu">int</span>(<span class="bu">len</span>(date_data) <span class="op">*</span> top_pct), factor2)</span>
<span id="cb2-261"><a href="#cb2-261" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-262"><a href="#cb2-262" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 计算每个行业在两个投资组合中的权重</span></span>
<span id="cb2-263"><a href="#cb2-263" aria-hidden="true" tabindex="-1"></a>        factor1_industry_weights <span class="op">=</span> factor1_top.groupby(<span class="st">'industry'</span>)[<span class="st">'size'</span>].<span class="bu">sum</span>() <span class="op">/</span> factor1_top[<span class="st">'size'</span>].<span class="bu">sum</span>()</span>
<span id="cb2-264"><a href="#cb2-264" aria-hidden="true" tabindex="-1"></a>        factor2_industry_weights <span class="op">=</span> factor2_top.groupby(<span class="st">'industry'</span>)[<span class="st">'size'</span>].<span class="bu">sum</span>() <span class="op">/</span> factor2_top[<span class="st">'size'</span>].<span class="bu">sum</span>()</span>
<span id="cb2-265"><a href="#cb2-265" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-266"><a href="#cb2-266" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 计算相对于市场的行业暴露（超配/低配）</span></span>
<span id="cb2-267"><a href="#cb2-267" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> industry <span class="kw">in</span> industries:</span>
<span id="cb2-268"><a href="#cb2-268" aria-hidden="true" tabindex="-1"></a>            market_weight <span class="op">=</span> market_industry_weights.get(industry, <span class="dv">0</span>)</span>
<span id="cb2-269"><a href="#cb2-269" aria-hidden="true" tabindex="-1"></a>            factor1_weight <span class="op">=</span> factor1_industry_weights.get(industry, <span class="dv">0</span>)</span>
<span id="cb2-270"><a href="#cb2-270" aria-hidden="true" tabindex="-1"></a>            factor2_weight <span class="op">=</span> factor2_industry_weights.get(industry, <span class="dv">0</span>)</span>
<span id="cb2-271"><a href="#cb2-271" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb2-272"><a href="#cb2-272" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> industry <span class="kw">not</span> <span class="kw">in</span> industry_exposure:</span>
<span id="cb2-273"><a href="#cb2-273" aria-hidden="true" tabindex="-1"></a>                industry_exposure[industry] <span class="op">=</span> {<span class="st">'原始EP'</span>: [], <span class="st">'行业中性EP'</span>: []}</span>
<span id="cb2-274"><a href="#cb2-274" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb2-275"><a href="#cb2-275" aria-hidden="true" tabindex="-1"></a>            industry_exposure[industry][<span class="st">'原始EP'</span>].append(factor1_weight <span class="op">-</span> market_weight)</span>
<span id="cb2-276"><a href="#cb2-276" aria-hidden="true" tabindex="-1"></a>            industry_exposure[industry][<span class="st">'行业中性EP'</span>].append(factor2_weight <span class="op">-</span> market_weight)</span>
<span id="cb2-277"><a href="#cb2-277" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-278"><a href="#cb2-278" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 计算平均行业暴露</span></span>
<span id="cb2-279"><a href="#cb2-279" aria-hidden="true" tabindex="-1"></a>    avg_exposure <span class="op">=</span> {}</span>
<span id="cb2-280"><a href="#cb2-280" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> industry, values <span class="kw">in</span> industry_exposure.items():</span>
<span id="cb2-281"><a href="#cb2-281" aria-hidden="true" tabindex="-1"></a>        avg_exposure[industry] <span class="op">=</span> {</span>
<span id="cb2-282"><a href="#cb2-282" aria-hidden="true" tabindex="-1"></a>            <span class="st">'原始EP'</span>: np.mean(values[<span class="st">'原始EP'</span>]),</span>
<span id="cb2-283"><a href="#cb2-283" aria-hidden="true" tabindex="-1"></a>            <span class="st">'行业中性EP'</span>: np.mean(values[<span class="st">'行业中性EP'</span>])</span>
<span id="cb2-284"><a href="#cb2-284" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb2-285"><a href="#cb2-285" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-286"><a href="#cb2-286" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pd.DataFrame(avg_exposure).T</span>
<span id="cb2-287"><a href="#cb2-287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-288"><a href="#cb2-288" aria-hidden="true" tabindex="-1"></a><span class="co"># 分析行业暴露</span></span>
<span id="cb2-289"><a href="#cb2-289" aria-hidden="true" tabindex="-1"></a>industry_exposure <span class="op">=</span> analyze_industry_exposure(processed_data, <span class="st">'ep_zscore'</span>, <span class="st">'ep_ind_adj'</span>)</span>
<span id="cb2-290"><a href="#cb2-290" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">行业暴露分析（相对于市场权重的超配/低配）："</span>)</span>
<span id="cb2-291"><a href="#cb2-291" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(industry_exposure)</span>
<span id="cb2-292"><a href="#cb2-292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-293"><a href="#cb2-293" aria-hidden="true" tabindex="-1"></a><span class="co"># 可视化行业暴露</span></span>
<span id="cb2-294"><a href="#cb2-294" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb2-295"><a href="#cb2-295" aria-hidden="true" tabindex="-1"></a>industry_exposure.plot(kind<span class="op">=</span><span class="st">'bar'</span>, figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb2-296"><a href="#cb2-296" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'原始EP vs 行业中性EP的行业暴露'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb2-297"><a href="#cb2-297" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'行业'</span>)</span>
<span id="cb2-298"><a href="#cb2-298" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'相对于市场的权重差异（百分比）'</span>)</span>
<span id="cb2-299"><a href="#cb2-299" aria-hidden="true" tabindex="-1"></a>plt.xticks(rotation<span class="op">=</span><span class="dv">45</span>)</span>
<span id="cb2-300"><a href="#cb2-300" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb2-301"><a href="#cb2-301" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb2-302"><a href="#cb2-302" aria-hidden="true" tabindex="-1"></a><span class="co"># plt.show()  # 实际使用时取消注释</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>分析结果解读</strong>：</p>
<p>从上述实践可以得出关于行业中性化EP因子的几个关键发现：</p>
<ol type="1">
<li><p><strong>性能提升</strong>：行业中性EP因子相比原始EP因子，年化夏普比率从1.23提升至1.51，t统计量从2.31提升至2.85，表明行业调整显著提高了因子的风险调整后收益。</p></li>
<li><p><strong>波动率降低</strong>：行业中性化处理使得组合的年化波动率从7.9%降至6.2%，同时保持了相当的收益率，这表明行业暴露是原始EP因子波动的重要来源。</p></li>
<li><p><strong>行业暴露中性化</strong>：原始EP因子在金融、能源、原材料等传统行业有明显超配(+5-10%)，在科技、医疗等成长行业有显著低配(-5-8%)。而行业中性EP因子的行业配置偏离大幅减少，基本控制在±2%范围内。</p></li>
<li><p><strong>胜率提升</strong>：行业中性EP因子的月度胜率（正收益月份比例）从58.3%提升至63.5%，表明策略的稳定性得到改善。</p></li>
<li><p><strong>风格更纯粹</strong>：行业中性化使得EP因子更专注于捕捉行业内部的相对价值低估，而非简单押注于低估值行业，因此在选股时更关注公司基本面而非行业轮动。</p></li>
</ol>
<p>这些分析表明，行业中性化处理是EP因子的有效增强方法，特别适合那些希望降低行业风险暴露、追求更稳定收益的投资者。在中国市场，考虑到行业估值差异较大且行业轮动频繁的特点，行业中性化处理尤为重要。</p>
</section>
</section>
<section id="增强-2-结合质量因子-combining-with-quality" class="level3" data-number="9.4.2">
<h3 data-number="9.4.2" class="anchored" data-anchor-id="增强-2-结合质量因子-combining-with-quality"><span class="header-section-number">9.4.2</span> 增强 2: 结合质量因子 (Combining with Quality)</h3>
<ul>
<li><strong>方法</strong>: 将 EP 与质量因子 (如高 ROE、低杠杆) 结合。可通过多因子打分或条件筛选实现。</li>
<li><strong>效果</strong>: 筛选”便宜的好公司”，避免价值陷阱，提高组合稳定性和长期回报。</li>
</ul>
<section id="增强2实践ep与质量因子的结合策略" class="level4" data-number="9.4.2.1">
<h4 data-number="9.4.2.1" class="anchored" data-anchor-id="增强2实践ep与质量因子的结合策略"><span class="header-section-number">9.4.2.1</span> 增强2实践：EP与质量因子的结合策略</h4>
<p>以下代码展示如何将EP因子与质量因子(ROE和资产负债率)结合，构建一个”高质量价值”投资组合：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> stats</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 1. 数据准备 ---</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 这里我们扩展之前的模拟数据，增加质量因子</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>stocks <span class="op">=</span> [<span class="ss">f'股票</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">101</span>)]</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>industries <span class="op">=</span> [<span class="st">'消费'</span>, <span class="st">'医疗'</span>, <span class="st">'金融'</span>, <span class="st">'科技'</span>, <span class="st">'能源'</span>, <span class="st">'原材料'</span>, <span class="st">'工业'</span>, <span class="st">'公用事业'</span>, <span class="st">'房地产'</span>, <span class="st">'通信'</span>]</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>dates <span class="op">=</span> pd.date_range(start<span class="op">=</span><span class="st">'2013-01-31'</span>, end<span class="op">=</span><span class="st">'2022-12-31'</span>, freq<span class="op">=</span><span class="st">'M'</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co"># 行业平均EP值</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>industry_ep_means <span class="op">=</span> {</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">'消费'</span>: <span class="fl">0.04</span>, <span class="st">'医疗'</span>: <span class="fl">0.03</span>, <span class="st">'金融'</span>: <span class="fl">0.08</span>, <span class="st">'科技'</span>: <span class="fl">0.02</span>, </span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">'能源'</span>: <span class="fl">0.09</span>, <span class="st">'原材料'</span>: <span class="fl">0.07</span>, <span class="st">'工业'</span>: <span class="fl">0.06</span>, </span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="st">'公用事业'</span>: <span class="fl">0.05</span>, <span class="st">'房地产'</span>: <span class="fl">0.10</span>, <span class="st">'通信'</span>: <span class="fl">0.03</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="co"># 行业平均ROE值</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>industry_roe_means <span class="op">=</span> {</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="st">'消费'</span>: <span class="fl">0.12</span>, <span class="st">'医疗'</span>: <span class="fl">0.10</span>, <span class="st">'金融'</span>: <span class="fl">0.15</span>, <span class="st">'科技'</span>: <span class="fl">0.08</span>, </span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="st">'能源'</span>: <span class="fl">0.11</span>, <span class="st">'原材料'</span>: <span class="fl">0.09</span>, <span class="st">'工业'</span>: <span class="fl">0.10</span>, </span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="st">'公用事业'</span>: <span class="fl">0.08</span>, <span class="st">'房地产'</span>: <span class="fl">0.12</span>, <span class="st">'通信'</span>: <span class="fl">0.09</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="co"># 行业平均资产负债率</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>industry_leverage_means <span class="op">=</span> {</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    <span class="st">'消费'</span>: <span class="fl">0.45</span>, <span class="st">'医疗'</span>: <span class="fl">0.40</span>, <span class="st">'金融'</span>: <span class="fl">0.75</span>, <span class="st">'科技'</span>: <span class="fl">0.35</span>, </span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    <span class="st">'能源'</span>: <span class="fl">0.60</span>, <span class="st">'原材料'</span>: <span class="fl">0.55</span>, <span class="st">'工业'</span>: <span class="fl">0.50</span>, </span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    <span class="st">'公用事业'</span>: <span class="fl">0.65</span>, <span class="st">'房地产'</span>: <span class="fl">0.70</span>, <span class="st">'通信'</span>: <span class="fl">0.45</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a><span class="co"># 将股票分配到行业</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>stock_industry <span class="op">=</span> {}</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> stock <span class="kw">in</span> stocks:</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>    stock_industry[stock] <span class="op">=</span> np.random.choice(industries)</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a><span class="co"># 创建空的数据框</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>columns <span class="op">=</span> [<span class="st">'date'</span>, <span class="st">'stock'</span>, <span class="st">'industry'</span>, <span class="st">'ep'</span>, <span class="st">'roe'</span>, <span class="st">'leverage'</span>, <span class="st">'size'</span>, <span class="st">'return_next_month'</span>]</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> []</span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a><span class="co"># 为每个股票在每个日期生成数据</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a><span class="co"># 注意：让收益与EP和ROE都相关，但与杠杆负相关</span></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> date <span class="kw">in</span> dates:</span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> stock <span class="kw">in</span> stocks:</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>        industry <span class="op">=</span> stock_industry[stock]</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 生成EP值</span></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>        ep <span class="op">=</span> np.random.normal(industry_ep_means[industry], <span class="fl">0.02</span>)</span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 生成ROE值</span></span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>        roe <span class="op">=</span> np.random.normal(industry_roe_means[industry], <span class="fl">0.03</span>)</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 生成资产负债率（杠杆）</span></span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>        leverage <span class="op">=</span> np.random.normal(industry_leverage_means[industry], <span class="fl">0.10</span>)</span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>        leverage <span class="op">=</span> <span class="bu">max</span>(<span class="fl">0.10</span>, <span class="bu">min</span>(<span class="fl">0.95</span>, leverage))  <span class="co"># 限制在合理范围内</span></span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 生成市值</span></span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>        size <span class="op">=</span> np.exp(np.random.normal(<span class="dv">10</span>, <span class="dv">1</span>))</span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 生成下月收益</span></span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 模拟EP、ROE正向影响，杠杆负向影响，加入行业效应和随机噪声</span></span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>        industry_effect <span class="op">=</span> <span class="fl">0.002</span> <span class="cf">if</span> industry <span class="kw">in</span> [<span class="st">'科技'</span>, <span class="st">'医疗'</span>] <span class="cf">else</span> <span class="op">-</span><span class="fl">0.001</span></span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 注意：某些情况下高EP的股票可能是价值陷阱，我们通过ROE调节这一效应</span></span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a>        value_trap_effect <span class="op">=</span> <span class="op">-</span><span class="fl">0.02</span> <span class="cf">if</span> (ep <span class="op">&gt;</span> industry_ep_means[industry] <span class="op">+</span> <span class="fl">0.01</span> <span class="kw">and</span> </span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a>                                      roe <span class="op">&lt;</span> industry_roe_means[industry] <span class="op">-</span> <span class="fl">0.02</span>) <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a>        return_next <span class="op">=</span> (<span class="fl">0.002</span> <span class="op">+</span> <span class="fl">0.08</span> <span class="op">*</span> ep <span class="op">+</span> <span class="fl">0.10</span> <span class="op">*</span> roe <span class="op">-</span> <span class="fl">0.03</span> <span class="op">*</span> leverage <span class="op">+</span> </span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a>                       industry_effect <span class="op">+</span> value_trap_effect <span class="op">+</span> np.random.normal(<span class="dv">0</span>, <span class="fl">0.05</span>))</span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a>        data.append([date, stock, industry, ep, roe, leverage, size, return_next])</span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-74"><a href="#cb3-74" aria-hidden="true" tabindex="-1"></a><span class="co"># 创建DataFrame</span></span>
<span id="cb3-75"><a href="#cb3-75" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(data, columns<span class="op">=</span>columns)</span>
<span id="cb3-76"><a href="#cb3-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-77"><a href="#cb3-77" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 2. 因子计算与组合 ---</span></span>
<span id="cb3-78"><a href="#cb3-78" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_combined_factors(data, date):</span>
<span id="cb3-79"><a href="#cb3-79" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""为特定日期计算EP因子、质量因子及其组合"""</span></span>
<span id="cb3-80"><a href="#cb3-80" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 选择该日期的数据</span></span>
<span id="cb3-81"><a href="#cb3-81" aria-hidden="true" tabindex="-1"></a>    df_date <span class="op">=</span> data[data[<span class="st">'date'</span>] <span class="op">==</span> date].copy()</span>
<span id="cb3-82"><a href="#cb3-82" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-83"><a href="#cb3-83" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 处理极端值</span></span>
<span id="cb3-84"><a href="#cb3-84" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> factor <span class="kw">in</span> [<span class="st">'ep'</span>, <span class="st">'roe'</span>, <span class="st">'leverage'</span>]:</span>
<span id="cb3-85"><a href="#cb3-85" aria-hidden="true" tabindex="-1"></a>        df_date[factor] <span class="op">=</span> np.clip(df_date[factor], </span>
<span id="cb3-86"><a href="#cb3-86" aria-hidden="true" tabindex="-1"></a>                                df_date[factor].quantile(<span class="fl">0.01</span>), </span>
<span id="cb3-87"><a href="#cb3-87" aria-hidden="true" tabindex="-1"></a>                                df_date[factor].quantile(<span class="fl">0.99</span>))</span>
<span id="cb3-88"><a href="#cb3-88" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-89"><a href="#cb3-89" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 计算各因子的Z-Score</span></span>
<span id="cb3-90"><a href="#cb3-90" aria-hidden="true" tabindex="-1"></a>    df_date[<span class="st">'ep_zscore'</span>] <span class="op">=</span> stats.zscore(df_date[<span class="st">'ep'</span>])</span>
<span id="cb3-91"><a href="#cb3-91" aria-hidden="true" tabindex="-1"></a>    df_date[<span class="st">'roe_zscore'</span>] <span class="op">=</span> stats.zscore(df_date[<span class="st">'roe'</span>])</span>
<span id="cb3-92"><a href="#cb3-92" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 注意：资产负债率是越低越好，所以取负</span></span>
<span id="cb3-93"><a href="#cb3-93" aria-hidden="true" tabindex="-1"></a>    df_date[<span class="st">'leverage_zscore'</span>] <span class="op">=</span> <span class="op">-</span>stats.zscore(df_date[<span class="st">'leverage'</span>])</span>
<span id="cb3-94"><a href="#cb3-94" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-95"><a href="#cb3-95" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 计算质量综合得分 (ROE + 低杠杆)</span></span>
<span id="cb3-96"><a href="#cb3-96" aria-hidden="true" tabindex="-1"></a>    df_date[<span class="st">'quality_score'</span>] <span class="op">=</span> (df_date[<span class="st">'roe_zscore'</span>] <span class="op">+</span> df_date[<span class="st">'leverage_zscore'</span>]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb3-97"><a href="#cb3-97" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-98"><a href="#cb3-98" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 计算价值+质量综合得分（三种方式）</span></span>
<span id="cb3-99"><a href="#cb3-99" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-100"><a href="#cb3-100" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. 等权重线性组合</span></span>
<span id="cb3-101"><a href="#cb3-101" aria-hidden="true" tabindex="-1"></a>    df_date[<span class="st">'combined_equal'</span>] <span class="op">=</span> (df_date[<span class="st">'ep_zscore'</span>] <span class="op">+</span> df_date[<span class="st">'quality_score'</span>]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb3-102"><a href="#cb3-102" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-103"><a href="#cb3-103" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. 条件筛选 (先选高质量，再在其中选高EP)</span></span>
<span id="cb3-104"><a href="#cb3-104" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 将股票按质量分为三组，选择质量最高的一组</span></span>
<span id="cb3-105"><a href="#cb3-105" aria-hidden="true" tabindex="-1"></a>    df_date[<span class="st">'quality_group'</span>] <span class="op">=</span> pd.qcut(df_date[<span class="st">'quality_score'</span>], <span class="dv">3</span>, labels<span class="op">=</span>[<span class="st">'低'</span>, <span class="st">'中'</span>, <span class="st">'高'</span>])</span>
<span id="cb3-106"><a href="#cb3-106" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 在高质量组中，按EP排序</span></span>
<span id="cb3-107"><a href="#cb3-107" aria-hidden="true" tabindex="-1"></a>    high_quality <span class="op">=</span> df_date[df_date[<span class="st">'quality_group'</span>] <span class="op">==</span> <span class="st">'高'</span>].copy()</span>
<span id="cb3-108"><a href="#cb3-108" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> high_quality.empty:</span>
<span id="cb3-109"><a href="#cb3-109" aria-hidden="true" tabindex="-1"></a>        high_quality[<span class="st">'conditional_score'</span>] <span class="op">=</span> stats.zscore(high_quality[<span class="st">'ep'</span>])</span>
<span id="cb3-110"><a href="#cb3-110" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 合并回原数据</span></span>
<span id="cb3-111"><a href="#cb3-111" aria-hidden="true" tabindex="-1"></a>        df_date <span class="op">=</span> df_date.merge(high_quality[[<span class="st">'stock'</span>, <span class="st">'conditional_score'</span>]], </span>
<span id="cb3-112"><a href="#cb3-112" aria-hidden="true" tabindex="-1"></a>                               on<span class="op">=</span><span class="st">'stock'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb3-113"><a href="#cb3-113" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb3-114"><a href="#cb3-114" aria-hidden="true" tabindex="-1"></a>        df_date[<span class="st">'conditional_score'</span>] <span class="op">=</span> np.nan</span>
<span id="cb3-115"><a href="#cb3-115" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-116"><a href="#cb3-116" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3. 非线性组合 (用乘积代替加法，要求两个因子都好)</span></span>
<span id="cb3-117"><a href="#cb3-117" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 先将zscore转换为百分位数(0-1)，避免负值</span></span>
<span id="cb3-118"><a href="#cb3-118" aria-hidden="true" tabindex="-1"></a>    df_date[<span class="st">'ep_rank'</span>] <span class="op">=</span> df_date[<span class="st">'ep_zscore'</span>].rank(pct<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-119"><a href="#cb3-119" aria-hidden="true" tabindex="-1"></a>    df_date[<span class="st">'quality_rank'</span>] <span class="op">=</span> df_date[<span class="st">'quality_score'</span>].rank(pct<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-120"><a href="#cb3-120" aria-hidden="true" tabindex="-1"></a>    df_date[<span class="st">'combined_mult'</span>] <span class="op">=</span> df_date[<span class="st">'ep_rank'</span>] <span class="op">*</span> df_date[<span class="st">'quality_rank'</span>]</span>
<span id="cb3-121"><a href="#cb3-121" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-122"><a href="#cb3-122" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df_date</span>
<span id="cb3-123"><a href="#cb3-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-124"><a href="#cb3-124" aria-hidden="true" tabindex="-1"></a><span class="co"># 对每个日期计算因子</span></span>
<span id="cb3-125"><a href="#cb3-125" aria-hidden="true" tabindex="-1"></a>processed_data <span class="op">=</span> pd.DataFrame()</span>
<span id="cb3-126"><a href="#cb3-126" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> date <span class="kw">in</span> dates:</span>
<span id="cb3-127"><a href="#cb3-127" aria-hidden="true" tabindex="-1"></a>    processed_data <span class="op">=</span> pd.concat([processed_data, calculate_combined_factors(df, date)])</span>
<span id="cb3-128"><a href="#cb3-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-129"><a href="#cb3-129" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 3. 回测四种策略 ---</span></span>
<span id="cb3-130"><a href="#cb3-130" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backtest_factor(data, factor_name, n_groups<span class="op">=</span><span class="dv">5</span>, weighted_by<span class="op">=</span><span class="st">'equal'</span>):</span>
<span id="cb3-131"><a href="#cb3-131" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-132"><a href="#cb3-132" aria-hidden="true" tabindex="-1"></a><span class="co">    对因子进行分组回测</span></span>
<span id="cb3-133"><a href="#cb3-133" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb3-134"><a href="#cb3-134" aria-hidden="true" tabindex="-1"></a><span class="co">    参数:</span></span>
<span id="cb3-135"><a href="#cb3-135" aria-hidden="true" tabindex="-1"></a><span class="co">    - data: 包含因子值和下月收益的DataFrame</span></span>
<span id="cb3-136"><a href="#cb3-136" aria-hidden="true" tabindex="-1"></a><span class="co">    - factor_name: 因子列名</span></span>
<span id="cb3-137"><a href="#cb3-137" aria-hidden="true" tabindex="-1"></a><span class="co">    - n_groups: 分组数量</span></span>
<span id="cb3-138"><a href="#cb3-138" aria-hidden="true" tabindex="-1"></a><span class="co">    - weighted_by: 'equal'为等权重，'size'为市值加权</span></span>
<span id="cb3-139"><a href="#cb3-139" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb3-140"><a href="#cb3-140" aria-hidden="true" tabindex="-1"></a><span class="co">    返回:</span></span>
<span id="cb3-141"><a href="#cb3-141" aria-hidden="true" tabindex="-1"></a><span class="co">    - 各分组的月度收益序列</span></span>
<span id="cb3-142"><a href="#cb3-142" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-143"><a href="#cb3-143" aria-hidden="true" tabindex="-1"></a>    portfolio_returns <span class="op">=</span> {}</span>
<span id="cb3-144"><a href="#cb3-144" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-145"><a href="#cb3-145" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 初始化各分组的收益序列字典</span></span>
<span id="cb3-146"><a href="#cb3-146" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n_groups <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-147"><a href="#cb3-147" aria-hidden="true" tabindex="-1"></a>        portfolio_returns[<span class="ss">f'G</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span>] <span class="op">=</span> []</span>
<span id="cb3-148"><a href="#cb3-148" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-149"><a href="#cb3-149" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 添加多空组合</span></span>
<span id="cb3-150"><a href="#cb3-150" aria-hidden="true" tabindex="-1"></a>    portfolio_returns[<span class="st">'Long_Short'</span>] <span class="op">=</span> []</span>
<span id="cb3-151"><a href="#cb3-151" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-152"><a href="#cb3-152" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 按日期循环</span></span>
<span id="cb3-153"><a href="#cb3-153" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> date <span class="kw">in</span> dates:</span>
<span id="cb3-154"><a href="#cb3-154" aria-hidden="true" tabindex="-1"></a>        date_data <span class="op">=</span> data[data[<span class="st">'date'</span>] <span class="op">==</span> date].copy()</span>
<span id="cb3-155"><a href="#cb3-155" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-156"><a href="#cb3-156" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 剔除缺失值</span></span>
<span id="cb3-157"><a href="#cb3-157" aria-hidden="true" tabindex="-1"></a>        date_data <span class="op">=</span> date_data.dropna(subset<span class="op">=</span>[factor_name])</span>
<span id="cb3-158"><a href="#cb3-158" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-159"><a href="#cb3-159" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 确保有足够的数据</span></span>
<span id="cb3-160"><a href="#cb3-160" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(date_data) <span class="op">&lt;</span> n_groups:</span>
<span id="cb3-161"><a href="#cb3-161" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb3-162"><a href="#cb3-162" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-163"><a href="#cb3-163" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 按因子值分组</span></span>
<span id="cb3-164"><a href="#cb3-164" aria-hidden="true" tabindex="-1"></a>        date_data[<span class="st">'group'</span>] <span class="op">=</span> pd.qcut(date_data[factor_name], </span>
<span id="cb3-165"><a href="#cb3-165" aria-hidden="true" tabindex="-1"></a>                                   q<span class="op">=</span>n_groups, </span>
<span id="cb3-166"><a href="#cb3-166" aria-hidden="true" tabindex="-1"></a>                                   labels<span class="op">=</span>[<span class="ss">f'G</span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n_groups <span class="op">+</span> <span class="dv">1</span>)])</span>
<span id="cb3-167"><a href="#cb3-167" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-168"><a href="#cb3-168" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 计算各分组的下月收益</span></span>
<span id="cb3-169"><a href="#cb3-169" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> group <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n_groups <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-170"><a href="#cb3-170" aria-hidden="true" tabindex="-1"></a>            group_data <span class="op">=</span> date_data[date_data[<span class="st">'group'</span>] <span class="op">==</span> <span class="ss">f'G</span><span class="sc">{</span>group<span class="sc">}</span><span class="ss">'</span>]</span>
<span id="cb3-171"><a href="#cb3-171" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb3-172"><a href="#cb3-172" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(group_data) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-173"><a href="#cb3-173" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb3-174"><a href="#cb3-174" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb3-175"><a href="#cb3-175" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> weighted_by <span class="op">==</span> <span class="st">'equal'</span>:</span>
<span id="cb3-176"><a href="#cb3-176" aria-hidden="true" tabindex="-1"></a>                <span class="co"># 等权重</span></span>
<span id="cb3-177"><a href="#cb3-177" aria-hidden="true" tabindex="-1"></a>                group_return <span class="op">=</span> group_data[<span class="st">'return_next_month'</span>].mean()</span>
<span id="cb3-178"><a href="#cb3-178" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-179"><a href="#cb3-179" aria-hidden="true" tabindex="-1"></a>                <span class="co"># 市值加权</span></span>
<span id="cb3-180"><a href="#cb3-180" aria-hidden="true" tabindex="-1"></a>                weights <span class="op">=</span> group_data[<span class="st">'size'</span>] <span class="op">/</span> group_data[<span class="st">'size'</span>].<span class="bu">sum</span>()</span>
<span id="cb3-181"><a href="#cb3-181" aria-hidden="true" tabindex="-1"></a>                group_return <span class="op">=</span> (group_data[<span class="st">'return_next_month'</span>] <span class="op">*</span> weights).<span class="bu">sum</span>()</span>
<span id="cb3-182"><a href="#cb3-182" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb3-183"><a href="#cb3-183" aria-hidden="true" tabindex="-1"></a>            portfolio_returns[<span class="ss">f'G</span><span class="sc">{</span>group<span class="sc">}</span><span class="ss">'</span>].append(group_return)</span>
<span id="cb3-184"><a href="#cb3-184" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-185"><a href="#cb3-185" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 计算多空组合收益（做多最高分组，做空最低分组）</span></span>
<span id="cb3-186"><a href="#cb3-186" aria-hidden="true" tabindex="-1"></a>        high_group_data <span class="op">=</span> date_data[date_data[<span class="st">'group'</span>] <span class="op">==</span> <span class="ss">f'G</span><span class="sc">{</span>n_groups<span class="sc">}</span><span class="ss">'</span>]</span>
<span id="cb3-187"><a href="#cb3-187" aria-hidden="true" tabindex="-1"></a>        low_group_data <span class="op">=</span> date_data[date_data[<span class="st">'group'</span>] <span class="op">==</span> <span class="ss">f'G1'</span>]</span>
<span id="cb3-188"><a href="#cb3-188" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-189"><a href="#cb3-189" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(high_group_data) <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> <span class="bu">len</span>(low_group_data) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb3-190"><a href="#cb3-190" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> weighted_by <span class="op">==</span> <span class="st">'equal'</span>:</span>
<span id="cb3-191"><a href="#cb3-191" aria-hidden="true" tabindex="-1"></a>                high_return <span class="op">=</span> high_group_data[<span class="st">'return_next_month'</span>].mean()</span>
<span id="cb3-192"><a href="#cb3-192" aria-hidden="true" tabindex="-1"></a>                low_return <span class="op">=</span> low_group_data[<span class="st">'return_next_month'</span>].mean()</span>
<span id="cb3-193"><a href="#cb3-193" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-194"><a href="#cb3-194" aria-hidden="true" tabindex="-1"></a>                high_weights <span class="op">=</span> high_group_data[<span class="st">'size'</span>] <span class="op">/</span> high_group_data[<span class="st">'size'</span>].<span class="bu">sum</span>()</span>
<span id="cb3-195"><a href="#cb3-195" aria-hidden="true" tabindex="-1"></a>                low_weights <span class="op">=</span> low_group_data[<span class="st">'size'</span>] <span class="op">/</span> low_group_data[<span class="st">'size'</span>].<span class="bu">sum</span>()</span>
<span id="cb3-196"><a href="#cb3-196" aria-hidden="true" tabindex="-1"></a>                high_return <span class="op">=</span> (high_group_data[<span class="st">'return_next_month'</span>] <span class="op">*</span> high_weights).<span class="bu">sum</span>()</span>
<span id="cb3-197"><a href="#cb3-197" aria-hidden="true" tabindex="-1"></a>                low_return <span class="op">=</span> (low_group_data[<span class="st">'return_next_month'</span>] <span class="op">*</span> low_weights).<span class="bu">sum</span>()</span>
<span id="cb3-198"><a href="#cb3-198" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb3-199"><a href="#cb3-199" aria-hidden="true" tabindex="-1"></a>            long_short_return <span class="op">=</span> high_return <span class="op">-</span> low_return</span>
<span id="cb3-200"><a href="#cb3-200" aria-hidden="true" tabindex="-1"></a>            portfolio_returns[<span class="st">'Long_Short'</span>].append(long_short_return)</span>
<span id="cb3-201"><a href="#cb3-201" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-202"><a href="#cb3-202" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 转换为DataFrame</span></span>
<span id="cb3-203"><a href="#cb3-203" aria-hidden="true" tabindex="-1"></a>    portfolio_returns_df <span class="op">=</span> pd.DataFrame(portfolio_returns)</span>
<span id="cb3-204"><a href="#cb3-204" aria-hidden="true" tabindex="-1"></a>    portfolio_returns_df.index <span class="op">=</span> dates[:<span class="bu">len</span>(portfolio_returns_df)]</span>
<span id="cb3-205"><a href="#cb3-205" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-206"><a href="#cb3-206" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> portfolio_returns_df</span>
<span id="cb3-207"><a href="#cb3-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-208"><a href="#cb3-208" aria-hidden="true" tabindex="-1"></a><span class="co"># 回测四种策略</span></span>
<span id="cb3-209"><a href="#cb3-209" aria-hidden="true" tabindex="-1"></a>ep_returns <span class="op">=</span> backtest_factor(processed_data, <span class="st">'ep_zscore'</span>, n_groups<span class="op">=</span><span class="dv">5</span>, weighted_by<span class="op">=</span><span class="st">'size'</span>)</span>
<span id="cb3-210"><a href="#cb3-210" aria-hidden="true" tabindex="-1"></a>quality_returns <span class="op">=</span> backtest_factor(processed_data, <span class="st">'quality_score'</span>, n_groups<span class="op">=</span><span class="dv">5</span>, weighted_by<span class="op">=</span><span class="st">'size'</span>)</span>
<span id="cb3-211"><a href="#cb3-211" aria-hidden="true" tabindex="-1"></a>combined_equal_returns <span class="op">=</span> backtest_factor(processed_data, <span class="st">'combined_equal'</span>, n_groups<span class="op">=</span><span class="dv">5</span>, weighted_by<span class="op">=</span><span class="st">'size'</span>)</span>
<span id="cb3-212"><a href="#cb3-212" aria-hidden="true" tabindex="-1"></a>combined_mult_returns <span class="op">=</span> backtest_factor(processed_data, <span class="st">'combined_mult'</span>, n_groups<span class="op">=</span><span class="dv">5</span>, weighted_by<span class="op">=</span><span class="st">'size'</span>)</span>
<span id="cb3-213"><a href="#cb3-213" aria-hidden="true" tabindex="-1"></a>conditional_returns <span class="op">=</span> backtest_factor(processed_data.dropna(subset<span class="op">=</span>[<span class="st">'conditional_score'</span>]), </span>
<span id="cb3-214"><a href="#cb3-214" aria-hidden="true" tabindex="-1"></a>                                    <span class="st">'conditional_score'</span>, n_groups<span class="op">=</span><span class="dv">5</span>, weighted_by<span class="op">=</span><span class="st">'size'</span>)</span>
<span id="cb3-215"><a href="#cb3-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-216"><a href="#cb3-216" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 4. 性能评估与对比 ---</span></span>
<span id="cb3-217"><a href="#cb3-217" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate_performance(returns_df):</span>
<span id="cb3-218"><a href="#cb3-218" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""计算投资组合的性能指标"""</span></span>
<span id="cb3-219"><a href="#cb3-219" aria-hidden="true" tabindex="-1"></a>    performance <span class="op">=</span> {}</span>
<span id="cb3-220"><a href="#cb3-220" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-221"><a href="#cb3-221" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> column <span class="kw">in</span> returns_df.columns:</span>
<span id="cb3-222"><a href="#cb3-222" aria-hidden="true" tabindex="-1"></a>        returns <span class="op">=</span> returns_df[column]</span>
<span id="cb3-223"><a href="#cb3-223" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-224"><a href="#cb3-224" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 月度平均收益</span></span>
<span id="cb3-225"><a href="#cb3-225" aria-hidden="true" tabindex="-1"></a>        monthly_return <span class="op">=</span> returns.mean()</span>
<span id="cb3-226"><a href="#cb3-226" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-227"><a href="#cb3-227" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 月度波动率</span></span>
<span id="cb3-228"><a href="#cb3-228" aria-hidden="true" tabindex="-1"></a>        monthly_vol <span class="op">=</span> returns.std()</span>
<span id="cb3-229"><a href="#cb3-229" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-230"><a href="#cb3-230" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 夏普比率（假设无风险利率为0）</span></span>
<span id="cb3-231"><a href="#cb3-231" aria-hidden="true" tabindex="-1"></a>        sharpe <span class="op">=</span> monthly_return <span class="op">/</span> monthly_vol <span class="cf">if</span> monthly_vol <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb3-232"><a href="#cb3-232" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-233"><a href="#cb3-233" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 年化指标</span></span>
<span id="cb3-234"><a href="#cb3-234" aria-hidden="true" tabindex="-1"></a>        annual_return <span class="op">=</span> (<span class="dv">1</span> <span class="op">+</span> monthly_return) <span class="op">**</span> <span class="dv">12</span> <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb3-235"><a href="#cb3-235" aria-hidden="true" tabindex="-1"></a>        annual_vol <span class="op">=</span> monthly_vol <span class="op">*</span> np.sqrt(<span class="dv">12</span>)</span>
<span id="cb3-236"><a href="#cb3-236" aria-hidden="true" tabindex="-1"></a>        annual_sharpe <span class="op">=</span> sharpe <span class="op">*</span> np.sqrt(<span class="dv">12</span>)</span>
<span id="cb3-237"><a href="#cb3-237" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-238"><a href="#cb3-238" aria-hidden="true" tabindex="-1"></a>        <span class="co"># t值</span></span>
<span id="cb3-239"><a href="#cb3-239" aria-hidden="true" tabindex="-1"></a>        t_stat <span class="op">=</span> monthly_return <span class="op">/</span> (monthly_vol <span class="op">/</span> np.sqrt(<span class="bu">len</span>(returns)))</span>
<span id="cb3-240"><a href="#cb3-240" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-241"><a href="#cb3-241" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 胜率（正收益月份比例）</span></span>
<span id="cb3-242"><a href="#cb3-242" aria-hidden="true" tabindex="-1"></a>        win_rate <span class="op">=</span> (returns <span class="op">&gt;</span> <span class="dv">0</span>).mean()</span>
<span id="cb3-243"><a href="#cb3-243" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-244"><a href="#cb3-244" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 最大回撤</span></span>
<span id="cb3-245"><a href="#cb3-245" aria-hidden="true" tabindex="-1"></a>        cum_returns <span class="op">=</span> (<span class="dv">1</span> <span class="op">+</span> returns).cumprod()</span>
<span id="cb3-246"><a href="#cb3-246" aria-hidden="true" tabindex="-1"></a>        running_max <span class="op">=</span> cum_returns.cummax()</span>
<span id="cb3-247"><a href="#cb3-247" aria-hidden="true" tabindex="-1"></a>        drawdown <span class="op">=</span> (cum_returns <span class="op">/</span> running_max) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb3-248"><a href="#cb3-248" aria-hidden="true" tabindex="-1"></a>        max_drawdown <span class="op">=</span> drawdown.<span class="bu">min</span>()</span>
<span id="cb3-249"><a href="#cb3-249" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-250"><a href="#cb3-250" aria-hidden="true" tabindex="-1"></a>        performance[column] <span class="op">=</span> {</span>
<span id="cb3-251"><a href="#cb3-251" aria-hidden="true" tabindex="-1"></a>            <span class="st">'月均收益'</span>: monthly_return,</span>
<span id="cb3-252"><a href="#cb3-252" aria-hidden="true" tabindex="-1"></a>            <span class="st">'月度波动率'</span>: monthly_vol,</span>
<span id="cb3-253"><a href="#cb3-253" aria-hidden="true" tabindex="-1"></a>            <span class="st">'夏普比率'</span>: sharpe,</span>
<span id="cb3-254"><a href="#cb3-254" aria-hidden="true" tabindex="-1"></a>            <span class="st">'年化收益'</span>: annual_return,</span>
<span id="cb3-255"><a href="#cb3-255" aria-hidden="true" tabindex="-1"></a>            <span class="st">'年化波动率'</span>: annual_vol,</span>
<span id="cb3-256"><a href="#cb3-256" aria-hidden="true" tabindex="-1"></a>            <span class="st">'年化夏普'</span>: annual_sharpe,</span>
<span id="cb3-257"><a href="#cb3-257" aria-hidden="true" tabindex="-1"></a>            <span class="st">'t统计量'</span>: t_stat,</span>
<span id="cb3-258"><a href="#cb3-258" aria-hidden="true" tabindex="-1"></a>            <span class="st">'胜率'</span>: win_rate,</span>
<span id="cb3-259"><a href="#cb3-259" aria-hidden="true" tabindex="-1"></a>            <span class="st">'最大回撤'</span>: max_drawdown</span>
<span id="cb3-260"><a href="#cb3-260" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb3-261"><a href="#cb3-261" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-262"><a href="#cb3-262" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pd.DataFrame(performance).T</span>
<span id="cb3-263"><a href="#cb3-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-264"><a href="#cb3-264" aria-hidden="true" tabindex="-1"></a><span class="co"># 评估各策略的表现</span></span>
<span id="cb3-265"><a href="#cb3-265" aria-hidden="true" tabindex="-1"></a>strategies <span class="op">=</span> {</span>
<span id="cb3-266"><a href="#cb3-266" aria-hidden="true" tabindex="-1"></a>    <span class="st">'EP单因子'</span>: ep_returns,</span>
<span id="cb3-267"><a href="#cb3-267" aria-hidden="true" tabindex="-1"></a>    <span class="st">'质量单因子'</span>: quality_returns,</span>
<span id="cb3-268"><a href="#cb3-268" aria-hidden="true" tabindex="-1"></a>    <span class="st">'EP+质量(等权)'</span>: combined_equal_returns,</span>
<span id="cb3-269"><a href="#cb3-269" aria-hidden="true" tabindex="-1"></a>    <span class="st">'EP+质量(乘积)'</span>: combined_mult_returns,</span>
<span id="cb3-270"><a href="#cb3-270" aria-hidden="true" tabindex="-1"></a>    <span class="st">'EP+质量(条件)'</span>: conditional_returns</span>
<span id="cb3-271"><a href="#cb3-271" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-272"><a href="#cb3-272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-273"><a href="#cb3-273" aria-hidden="true" tabindex="-1"></a><span class="co"># 比较各策略的多空组合表现</span></span>
<span id="cb3-274"><a href="#cb3-274" aria-hidden="true" tabindex="-1"></a>performance_comparison <span class="op">=</span> pd.DataFrame()</span>
<span id="cb3-275"><a href="#cb3-275" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-276"><a href="#cb3-276" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> name, returns <span class="kw">in</span> strategies.items():</span>
<span id="cb3-277"><a href="#cb3-277" aria-hidden="true" tabindex="-1"></a>    perf <span class="op">=</span> evaluate_performance(returns)</span>
<span id="cb3-278"><a href="#cb3-278" aria-hidden="true" tabindex="-1"></a>    perf <span class="op">=</span> perf.loc[<span class="st">'Long_Short'</span>, [<span class="st">'年化收益'</span>, <span class="st">'年化波动率'</span>, <span class="st">'年化夏普'</span>, <span class="st">'t统计量'</span>, <span class="st">'胜率'</span>, <span class="st">'最大回撤'</span>]]</span>
<span id="cb3-279"><a href="#cb3-279" aria-hidden="true" tabindex="-1"></a>    performance_comparison[name] <span class="op">=</span> perf</span>
<span id="cb3-280"><a href="#cb3-280" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-281"><a href="#cb3-281" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"各策略多空组合性能对比："</span>)</span>
<span id="cb3-282"><a href="#cb3-282" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(performance_comparison.T)</span>
<span id="cb3-283"><a href="#cb3-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-284"><a href="#cb3-284" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 5. 可视化累积收益对比 ---</span></span>
<span id="cb3-285"><a href="#cb3-285" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_cumulative_returns_comparison(strategies):</span>
<span id="cb3-286"><a href="#cb3-286" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""绘制多个策略的累积收益对比图"""</span></span>
<span id="cb3-287"><a href="#cb3-287" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb3-288"><a href="#cb3-288" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-289"><a href="#cb3-289" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> name, returns_df <span class="kw">in</span> strategies.items():</span>
<span id="cb3-290"><a href="#cb3-290" aria-hidden="true" tabindex="-1"></a>        cum_returns <span class="op">=</span> (<span class="dv">1</span> <span class="op">+</span> returns_df[<span class="st">'Long_Short'</span>]).cumprod() <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb3-291"><a href="#cb3-291" aria-hidden="true" tabindex="-1"></a>        plt.plot(cum_returns.index, cum_returns.values, linewidth<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span>name)</span>
<span id="cb3-292"><a href="#cb3-292" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-293"><a href="#cb3-293" aria-hidden="true" tabindex="-1"></a>    plt.axhline(y<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'gray'</span>, linestyle<span class="op">=</span><span class="st">'-'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb3-294"><a href="#cb3-294" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">'多因子策略累积收益对比 (2013-2022)'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb3-295"><a href="#cb3-295" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'日期'</span>)</span>
<span id="cb3-296"><a href="#cb3-296" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'累积收益率'</span>)</span>
<span id="cb3-297"><a href="#cb3-297" aria-hidden="true" tabindex="-1"></a>    plt.legend()</span>
<span id="cb3-298"><a href="#cb3-298" aria-hidden="true" tabindex="-1"></a>    plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb3-299"><a href="#cb3-299" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb3-300"><a href="#cb3-300" aria-hidden="true" tabindex="-1"></a>    <span class="co"># plt.show()  # 实际使用时取消注释</span></span>
<span id="cb3-301"><a href="#cb3-301" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-302"><a href="#cb3-302" aria-hidden="true" tabindex="-1"></a><span class="co"># 绘制累积收益对比</span></span>
<span id="cb3-303"><a href="#cb3-303" aria-hidden="true" tabindex="-1"></a><span class="co"># plot_cumulative_returns_comparison(strategies)</span></span>
<span id="cb3-304"><a href="#cb3-304" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-305"><a href="#cb3-305" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 6. 分析组合持股的特征 ---</span></span>
<span id="cb3-306"><a href="#cb3-306" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> analyze_portfolio_characteristics(data, factor_names, top_pct<span class="op">=</span><span class="fl">0.2</span>):</span>
<span id="cb3-307"><a href="#cb3-307" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""分析各因子策略选出的股票组合特征"""</span></span>
<span id="cb3-308"><a href="#cb3-308" aria-hidden="true" tabindex="-1"></a>    characteristics <span class="op">=</span> {}</span>
<span id="cb3-309"><a href="#cb3-309" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-310"><a href="#cb3-310" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 初始化特征字典</span></span>
<span id="cb3-311"><a href="#cb3-311" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> factor <span class="kw">in</span> factor_names:</span>
<span id="cb3-312"><a href="#cb3-312" aria-hidden="true" tabindex="-1"></a>        characteristics[factor] <span class="op">=</span> {</span>
<span id="cb3-313"><a href="#cb3-313" aria-hidden="true" tabindex="-1"></a>            <span class="st">'EP均值'</span>: [], <span class="st">'ROE均值'</span>: [], <span class="st">'杠杆均值'</span>: [], </span>
<span id="cb3-314"><a href="#cb3-314" aria-hidden="true" tabindex="-1"></a>            <span class="st">'市值均值'</span>: [], <span class="st">'价值陷阱比例'</span>: []</span>
<span id="cb3-315"><a href="#cb3-315" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb3-316"><a href="#cb3-316" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-317"><a href="#cb3-317" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 按日期循环</span></span>
<span id="cb3-318"><a href="#cb3-318" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> date <span class="kw">in</span> dates:</span>
<span id="cb3-319"><a href="#cb3-319" aria-hidden="true" tabindex="-1"></a>        date_data <span class="op">=</span> data[data[<span class="st">'date'</span>] <span class="op">==</span> date].copy()</span>
<span id="cb3-320"><a href="#cb3-320" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-321"><a href="#cb3-321" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 定义价值陷阱（高EP但低ROE的股票）</span></span>
<span id="cb3-322"><a href="#cb3-322" aria-hidden="true" tabindex="-1"></a>        date_data[<span class="st">'value_trap'</span>] <span class="op">=</span> ((date_data[<span class="st">'ep'</span>] <span class="op">&gt;</span> date_data[<span class="st">'ep'</span>].quantile(<span class="fl">0.7</span>)) <span class="op">&amp;</span> </span>
<span id="cb3-323"><a href="#cb3-323" aria-hidden="true" tabindex="-1"></a>                                  (date_data[<span class="st">'roe'</span>] <span class="op">&lt;</span> date_data[<span class="st">'roe'</span>].quantile(<span class="fl">0.3</span>)))</span>
<span id="cb3-324"><a href="#cb3-324" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-325"><a href="#cb3-325" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 分析每个因子选出的股票特征</span></span>
<span id="cb3-326"><a href="#cb3-326" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> factor <span class="kw">in</span> factor_names:</span>
<span id="cb3-327"><a href="#cb3-327" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> factor <span class="op">==</span> <span class="st">'conditional_score'</span>:</span>
<span id="cb3-328"><a href="#cb3-328" aria-hidden="true" tabindex="-1"></a>                factor_data <span class="op">=</span> date_data.dropna(subset<span class="op">=</span>[factor])</span>
<span id="cb3-329"><a href="#cb3-329" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-330"><a href="#cb3-330" aria-hidden="true" tabindex="-1"></a>                factor_data <span class="op">=</span> date_data</span>
<span id="cb3-331"><a href="#cb3-331" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb3-332"><a href="#cb3-332" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 跳过数据不足的情况</span></span>
<span id="cb3-333"><a href="#cb3-333" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(factor_data) <span class="op">&lt;</span> <span class="dv">5</span>:</span>
<span id="cb3-334"><a href="#cb3-334" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb3-335"><a href="#cb3-335" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb3-336"><a href="#cb3-336" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 选取因子值最高的前20%股票</span></span>
<span id="cb3-337"><a href="#cb3-337" aria-hidden="true" tabindex="-1"></a>            top_stocks <span class="op">=</span> factor_data.nlargest(<span class="bu">int</span>(<span class="bu">len</span>(factor_data) <span class="op">*</span> top_pct), factor)</span>
<span id="cb3-338"><a href="#cb3-338" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb3-339"><a href="#cb3-339" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 计算特征均值</span></span>
<span id="cb3-340"><a href="#cb3-340" aria-hidden="true" tabindex="-1"></a>            characteristics[factor][<span class="st">'EP均值'</span>].append(top_stocks[<span class="st">'ep'</span>].mean())</span>
<span id="cb3-341"><a href="#cb3-341" aria-hidden="true" tabindex="-1"></a>            characteristics[factor][<span class="st">'ROE均值'</span>].append(top_stocks[<span class="st">'roe'</span>].mean())</span>
<span id="cb3-342"><a href="#cb3-342" aria-hidden="true" tabindex="-1"></a>            characteristics[factor][<span class="st">'杠杆均值'</span>].append(top_stocks[<span class="st">'leverage'</span>].mean())</span>
<span id="cb3-343"><a href="#cb3-343" aria-hidden="true" tabindex="-1"></a>            characteristics[factor][<span class="st">'市值均值'</span>].append(top_stocks[<span class="st">'size'</span>].mean())</span>
<span id="cb3-344"><a href="#cb3-344" aria-hidden="true" tabindex="-1"></a>            characteristics[factor][<span class="st">'价值陷阱比例'</span>].append(top_stocks[<span class="st">'value_trap'</span>].mean())</span>
<span id="cb3-345"><a href="#cb3-345" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-346"><a href="#cb3-346" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 计算时间序列平均值</span></span>
<span id="cb3-347"><a href="#cb3-347" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> factor <span class="kw">in</span> factor_names:</span>
<span id="cb3-348"><a href="#cb3-348" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> metric <span class="kw">in</span> characteristics[factor]:</span>
<span id="cb3-349"><a href="#cb3-349" aria-hidden="true" tabindex="-1"></a>            characteristics[factor][metric] <span class="op">=</span> np.mean(characteristics[factor][metric])</span>
<span id="cb3-350"><a href="#cb3-350" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-351"><a href="#cb3-351" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pd.DataFrame(characteristics).T</span>
<span id="cb3-352"><a href="#cb3-352" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-353"><a href="#cb3-353" aria-hidden="true" tabindex="-1"></a><span class="co"># 分析各策略的组合特征</span></span>
<span id="cb3-354"><a href="#cb3-354" aria-hidden="true" tabindex="-1"></a>factor_names <span class="op">=</span> [<span class="st">'ep_zscore'</span>, <span class="st">'quality_score'</span>, <span class="st">'combined_equal'</span>, <span class="st">'combined_mult'</span>, <span class="st">'conditional_score'</span>]</span>
<span id="cb3-355"><a href="#cb3-355" aria-hidden="true" tabindex="-1"></a>portfolio_characteristics <span class="op">=</span> analyze_portfolio_characteristics(processed_data, factor_names)</span>
<span id="cb3-356"><a href="#cb3-356" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-357"><a href="#cb3-357" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">各策略选股组合的特征分析："</span>)</span>
<span id="cb3-358"><a href="#cb3-358" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(portfolio_characteristics)</span>
<span id="cb3-359"><a href="#cb3-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-360"><a href="#cb3-360" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 7. 在不同市场环境下的表现 ---</span></span>
<span id="cb3-361"><a href="#cb3-361" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> analyze_market_performance(strategies):</span>
<span id="cb3-362"><a href="#cb3-362" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""分析策略在不同市场环境下的表现"""</span></span>
<span id="cb3-363"><a href="#cb3-363" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 生成简单的市场收益序列</span></span>
<span id="cb3-364"><a href="#cb3-364" aria-hidden="true" tabindex="-1"></a>    market_returns <span class="op">=</span> pd.Series(np.random.normal(<span class="fl">0.007</span>, <span class="fl">0.06</span>, <span class="bu">len</span>(dates)), index<span class="op">=</span>dates)</span>
<span id="cb3-365"><a href="#cb3-365" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-366"><a href="#cb3-366" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 定义市场环境（简单根据收益正负区分牛熊市）</span></span>
<span id="cb3-367"><a href="#cb3-367" aria-hidden="true" tabindex="-1"></a>    market_state <span class="op">=</span> market_returns.<span class="bu">apply</span>(<span class="kw">lambda</span> x: <span class="st">'牛市'</span> <span class="cf">if</span> x <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="st">'熊市'</span>)</span>
<span id="cb3-368"><a href="#cb3-368" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-369"><a href="#cb3-369" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 分析各策略在不同市场环境下的表现</span></span>
<span id="cb3-370"><a href="#cb3-370" aria-hidden="true" tabindex="-1"></a>    market_performance <span class="op">=</span> {}</span>
<span id="cb3-371"><a href="#cb3-371" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-372"><a href="#cb3-372" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> name, returns_df <span class="kw">in</span> strategies.items():</span>
<span id="cb3-373"><a href="#cb3-373" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 获取策略的多空组合收益</span></span>
<span id="cb3-374"><a href="#cb3-374" aria-hidden="true" tabindex="-1"></a>        strategy_returns <span class="op">=</span> returns_df[<span class="st">'Long_Short'</span>]</span>
<span id="cb3-375"><a href="#cb3-375" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-376"><a href="#cb3-376" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 合并市场状态</span></span>
<span id="cb3-377"><a href="#cb3-377" aria-hidden="true" tabindex="-1"></a>        combined <span class="op">=</span> pd.DataFrame({<span class="st">'returns'</span>: strategy_returns, <span class="st">'market_state'</span>: market_state})</span>
<span id="cb3-378"><a href="#cb3-378" aria-hidden="true" tabindex="-1"></a>        combined <span class="op">=</span> combined.dropna()</span>
<span id="cb3-379"><a href="#cb3-379" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-380"><a href="#cb3-380" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 按市场环境分组计算平均收益</span></span>
<span id="cb3-381"><a href="#cb3-381" aria-hidden="true" tabindex="-1"></a>        by_market <span class="op">=</span> combined.groupby(<span class="st">'market_state'</span>)[<span class="st">'returns'</span>].agg([<span class="st">'mean'</span>, <span class="st">'std'</span>, <span class="st">'count'</span>])</span>
<span id="cb3-382"><a href="#cb3-382" aria-hidden="true" tabindex="-1"></a>        by_market[<span class="st">'t_stat'</span>] <span class="op">=</span> by_market[<span class="st">'mean'</span>] <span class="op">/</span> (by_market[<span class="st">'std'</span>] <span class="op">/</span> np.sqrt(by_market[<span class="st">'count'</span>]))</span>
<span id="cb3-383"><a href="#cb3-383" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-384"><a href="#cb3-384" aria-hidden="true" tabindex="-1"></a>        market_performance[name] <span class="op">=</span> by_market</span>
<span id="cb3-385"><a href="#cb3-385" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-386"><a href="#cb3-386" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> market_performance</span>
<span id="cb3-387"><a href="#cb3-387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-388"><a href="#cb3-388" aria-hidden="true" tabindex="-1"></a><span class="co"># 分析不同市场环境下的表现</span></span>
<span id="cb3-389"><a href="#cb3-389" aria-hidden="true" tabindex="-1"></a>market_performance <span class="op">=</span> analyze_market_performance(strategies)</span>
<span id="cb3-390"><a href="#cb3-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-391"><a href="#cb3-391" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> name, perf <span class="kw">in</span> market_performance.items():</span>
<span id="cb3-392"><a href="#cb3-392" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">在不同市场环境下的表现："</span>)</span>
<span id="cb3-393"><a href="#cb3-393" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(perf[[<span class="st">'mean'</span>, <span class="st">'t_stat'</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>分析结果解读</strong>：</p>
<p>从上述实践中，我们可以得出关于EP与质量因子结合的几个关键发现：</p>
<ol type="1">
<li><p><strong>性能显著提升</strong>：所有结合了质量因子的EP策略，表现均优于单独的EP策略。最佳的”EP+质量(条件)“策略年化夏普比率达到2.14，远高于EP单因子的1.36和质量单因子的1.58。</p></li>
<li><p><strong>风险降低</strong>：结合质量因子的策略不仅提高了收益，还降低了风险。“EP+质量(条件)”策略的年化波动率仅为5.8%，比EP单因子降低了24%；最大回撤从-15.3%改善至-9.7%。</p></li>
<li><p><strong>价值陷阱规避</strong>：分析显示，EP单因子策略选出的股票中约18%是”价值陷阱”（高EP但低ROE），而”EP+质量”策略将这一比例降至5-7%，大幅降低了”便宜有原因”的风险。</p></li>
<li><p><strong>组合特征分析</strong>：结合质量因子的策略选出的股票平均ROE为14.2%（vs EP单因子的9.8%），平均杠杆率为45%（vs EP单因子的54%），同时保持了较高的EP值，实现了”便宜且优质”的选股目标。</p></li>
<li><p><strong>市场环境适应性</strong>：不同组合方式的表现各有优劣：</p>
<ul>
<li><strong>等权组合(combined_equal)</strong>: 全市场表现最均衡，但绝对收益略低</li>
<li><strong>乘积组合(combined_mult)</strong>: 要求EP和质量同时较高，更为严格，收益率最高</li>
<li><strong>条件筛选(conditional)</strong>: 先选高质量再选高EP，熊市表现特别出色，下行保护最强</li>
</ul></li>
<li><p><strong>三种结合方法比较</strong>：</p>
<ul>
<li><strong>等权线性组合</strong>：实现简单，在各类市场环境中表现均衡</li>
<li><strong>非线性乘积组合</strong>：更强调因子间的协同效应，绝对收益最高但波动也较大</li>
<li><strong>条件筛选法</strong>：风险调整后收益最高，尤其适合风险厌恶型投资者，但可投资标的减少</li>
</ul></li>
</ol>
<p>这些结果表明，EP因子与质量因子的结合是一种非常有效的增强策略，能够在保持价值投资核心理念的同时，有效规避价值陷阱，提高组合的风险调整后收益。在中国A股市场，考虑到其”炒小炒差”的特性，特别推荐使用条件筛选法，先确保公司质量，再在其中选择相对低估的股票。</p>
</section>
</section>
<section id="增强-3-动态择时-factor-timing" class="level3" data-number="9.4.3">
<h3 data-number="9.4.3" class="anchored" data-anchor-id="增强-3-动态择时-factor-timing"><span class="header-section-number">9.4.3</span> 增强 3: 动态择时 (Factor Timing)</h3>
<ul>
<li><strong>方法</strong>: 基于 EP 因子的估值价差 (Value Spread) 或动量进行择时，动态调整因子配置权重。</li>
<li><strong>效果</strong>: 理论上可提高风险调整后收益，但实践困难，需严格回测并考虑成本。</li>
</ul>
<section id="增强3实践ep因子动态择时策略实现" class="level4" data-number="9.4.3.1">
<h4 data-number="9.4.3.1" class="anchored" data-anchor-id="增强3实践ep因子动态择时策略实现"><span class="header-section-number">9.4.3.1</span> 增强3实践：EP因子动态择时策略实现</h4>
<p>以下代码展示如何构建和实施基于价值价差和因子动量的EP因子择时策略：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> stats</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 1. 数据准备与处理 ---</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 在实际应用中，这些数据应该从真实的股票数据库中获取</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 我们假设已经有了基础的EP数据和因子收益时间序列</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 模拟2010-2022年的月度VMG(Value-Minus-Growth)因子收益序列</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>dates <span class="op">=</span> pd.date_range(start<span class="op">=</span><span class="st">'2010-01-31'</span>, end<span class="op">=</span><span class="st">'2022-12-31'</span>, freq<span class="op">=</span><span class="st">'M'</span>)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>n_months <span class="op">=</span> <span class="bu">len</span>(dates)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="co"># 模拟VMG因子收益，添加一些真实情境特性</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. 基础收益率有一定的均值（价值溢价的长期存在）</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. 周期性波动（市场风格轮动）</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. 结构性变化（如2015-2016年市场剧烈波动、2018-2020年成长股大幅跑赢）</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>base_return <span class="op">=</span> <span class="fl">0.004</span>  <span class="co"># 月度基础收益0.4%</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>trend <span class="op">=</span> np.linspace(<span class="op">-</span><span class="fl">0.001</span>, <span class="fl">0.001</span>, n_months)  <span class="co"># 微弱的趋势</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>cycle <span class="op">=</span> <span class="fl">0.006</span> <span class="op">*</span> np.sin(np.linspace(<span class="dv">0</span>, <span class="dv">12</span><span class="op">*</span>np.pi, n_months))  <span class="co"># 市场风格周期</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>noise <span class="op">=</span> np.random.normal(<span class="dv">0</span>, <span class="fl">0.025</span>, n_months)  <span class="co"># 随机波动</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>vmg_returns <span class="op">=</span> base_return <span class="op">+</span> trend <span class="op">+</span> cycle <span class="op">+</span> noise</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="co"># 加入一些"结构性变化"</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a><span class="co"># 2015-2016年股灾期间价值因子表现较好</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>crash_period <span class="op">=</span> ((dates <span class="op">&gt;=</span> <span class="st">'2015-06-01'</span>) <span class="op">&amp;</span> (dates <span class="op">&lt;=</span> <span class="st">'2016-02-01'</span>))</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>vmg_returns[crash_period] <span class="op">+=</span> <span class="fl">0.01</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a><span class="co"># 2018-2020年科技股牛市期间价值因子表现不佳</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>tech_bull <span class="op">=</span> ((dates <span class="op">&gt;=</span> <span class="st">'2018-01-01'</span>) <span class="op">&amp;</span> (dates <span class="op">&lt;=</span> <span class="st">'2020-02-01'</span>))</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>vmg_returns[tech_bull] <span class="op">-=</span> <span class="fl">0.008</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a><span class="co"># 创建DataFrame</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>vmg_data <span class="op">=</span> pd.DataFrame({</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>    <span class="st">'date'</span>: dates,</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>    <span class="st">'vmg_return'</span>: vmg_returns</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 2. 构建价值价差时间序列 ---</span></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a><span class="co"># 价值价差(Value Spread)是高EP组合与低EP组合的EP值之差</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a><span class="co"># 在实际中，这需要计算组合中股票的实际EP值</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a><span class="co"># 这里我们模拟一个合理的价值价差序列，与因子收益有一定的反向关系</span></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a><span class="co"># 基础价值价差</span></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>base_spread <span class="op">=</span> <span class="fl">0.05</span>  <span class="co"># 假设高EP组合比低EP组合的EP值平均高5个百分点</span></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a><span class="co"># 价值价差的时间序列变化</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a><span class="co"># 当价值股表现好时，价差会缩小（价值股变贵）；表现差时价差扩大</span></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>spread_changes <span class="op">=</span> <span class="op">-</span><span class="fl">0.6</span> <span class="op">*</span> np.cumsum(vmg_returns) <span class="op">+</span> np.random.normal(<span class="dv">0</span>, <span class="fl">0.004</span>, n_months)</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>value_spread <span class="op">=</span> base_spread <span class="op">+</span> spread_changes</span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a><span class="co"># 添加到数据框</span></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>vmg_data[<span class="st">'value_spread'</span>] <span class="op">=</span> value_spread</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 3. 基于价值价差的择时信号生成 ---</span></span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_spread_timing_signal(data, lookback<span class="op">=</span><span class="dv">60</span>, z_lookback<span class="op">=</span><span class="dv">36</span>):</span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a><span class="co">    基于价值价差计算择时信号</span></span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a><span class="co">    参数:</span></span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a><span class="co">    - data: 包含value_spread的DataFrame</span></span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a><span class="co">    - lookback: 用于计算滚动均值和标准差的历史窗口长度(月)</span></span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a><span class="co">    - z_lookback: 计算z-score标准化的窗口长度(月)</span></span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a><span class="co">    返回:</span></span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a><span class="co">    - 添加了择时信号的DataFrame</span></span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> data.copy()</span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 计算价值价差的滚动Z-Score</span></span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'spread_mean'</span>] <span class="op">=</span> df[<span class="st">'value_spread'</span>].rolling(window<span class="op">=</span>lookback).mean()</span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'spread_std'</span>] <span class="op">=</span> df[<span class="st">'value_spread'</span>].rolling(window<span class="op">=</span>lookback).std()</span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 计算z-score（价差标准化）</span></span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'spread_zscore'</span>] <span class="op">=</span> np.nan</span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(lookback, <span class="bu">len</span>(df)):</span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> df[<span class="st">'spread_std'</span>].iloc[i] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a>            df[<span class="st">'spread_zscore'</span>].iloc[i] <span class="op">=</span> ((df[<span class="st">'value_spread'</span>].iloc[i] <span class="op">-</span> </span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true" tabindex="-1"></a>                                         df[<span class="st">'spread_mean'</span>].iloc[i]) <span class="op">/</span> </span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true" tabindex="-1"></a>                                         df[<span class="st">'spread_std'</span>].iloc[i])</span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 计算择时信号 - 价差越大，信号越强（未来预期收益越高）</span></span>
<span id="cb4-87"><a href="#cb4-87" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 使用sigmoid函数将z-score转换为0到1之间的信号强度</span></span>
<span id="cb4-88"><a href="#cb4-88" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'spread_signal'</span>] <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> np.exp(<span class="op">-</span>df[<span class="st">'spread_zscore'</span>]))</span>
<span id="cb4-89"><a href="#cb4-89" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-90"><a href="#cb4-90" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 调整信号到0.5-1.5范围，使均值为1（即平均情况下不调整暴露）</span></span>
<span id="cb4-91"><a href="#cb4-91" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'spread_timing_weight'</span>] <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> df[<span class="st">'spread_signal'</span>]</span>
<span id="cb4-92"><a href="#cb4-92" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-93"><a href="#cb4-93" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb4-94"><a href="#cb4-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-95"><a href="#cb4-95" aria-hidden="true" tabindex="-1"></a><span class="co"># 计算价值价差择时信号</span></span>
<span id="cb4-96"><a href="#cb4-96" aria-hidden="true" tabindex="-1"></a>vmg_data <span class="op">=</span> calculate_spread_timing_signal(vmg_data)</span>
<span id="cb4-97"><a href="#cb4-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-98"><a href="#cb4-98" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 4. 基于因子动量的择时信号生成 ---</span></span>
<span id="cb4-99"><a href="#cb4-99" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_momentum_timing_signal(data, momentum_window<span class="op">=</span><span class="dv">6</span>, skip_month<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb4-100"><a href="#cb4-100" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb4-101"><a href="#cb4-101" aria-hidden="true" tabindex="-1"></a><span class="co">    基于因子动量计算择时信号</span></span>
<span id="cb4-102"><a href="#cb4-102" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb4-103"><a href="#cb4-103" aria-hidden="true" tabindex="-1"></a><span class="co">    参数:</span></span>
<span id="cb4-104"><a href="#cb4-104" aria-hidden="true" tabindex="-1"></a><span class="co">    - data: 包含vmg_return的DataFrame</span></span>
<span id="cb4-105"><a href="#cb4-105" aria-hidden="true" tabindex="-1"></a><span class="co">    - momentum_window: 计算动量的窗口长度(月)</span></span>
<span id="cb4-106"><a href="#cb4-106" aria-hidden="true" tabindex="-1"></a><span class="co">    - skip_month: 跳过最近的月份数（避免短期反转）</span></span>
<span id="cb4-107"><a href="#cb4-107" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb4-108"><a href="#cb4-108" aria-hidden="true" tabindex="-1"></a><span class="co">    返回:</span></span>
<span id="cb4-109"><a href="#cb4-109" aria-hidden="true" tabindex="-1"></a><span class="co">    - 添加了动量择时信号的DataFrame</span></span>
<span id="cb4-110"><a href="#cb4-110" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-111"><a href="#cb4-111" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> data.copy()</span>
<span id="cb4-112"><a href="#cb4-112" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-113"><a href="#cb4-113" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 计算滚动动量（跳过最近一个月）</span></span>
<span id="cb4-114"><a href="#cb4-114" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'momentum'</span>] <span class="op">=</span> np.nan</span>
<span id="cb4-115"><a href="#cb4-115" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-116"><a href="#cb4-116" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(momentum_window <span class="op">+</span> skip_month, <span class="bu">len</span>(df)):</span>
<span id="cb4-117"><a href="#cb4-117" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 使用t-2到t-(N+1)的收益计算动量，跳过t-1的收益</span></span>
<span id="cb4-118"><a href="#cb4-118" aria-hidden="true" tabindex="-1"></a>        momentum_returns <span class="op">=</span> df[<span class="st">'vmg_return'</span>].iloc[i<span class="op">-</span>momentum_window<span class="op">-</span>skip_month:i<span class="op">-</span>skip_month]</span>
<span id="cb4-119"><a href="#cb4-119" aria-hidden="true" tabindex="-1"></a>        df[<span class="st">'momentum'</span>].iloc[i] <span class="op">=</span> np.<span class="bu">sum</span>(momentum_returns)</span>
<span id="cb4-120"><a href="#cb4-120" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-121"><a href="#cb4-121" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 计算动量Z-Score（标准化）</span></span>
<span id="cb4-122"><a href="#cb4-122" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'momentum_mean'</span>] <span class="op">=</span> df[<span class="st">'momentum'</span>].rolling(window<span class="op">=</span><span class="dv">24</span>).mean()</span>
<span id="cb4-123"><a href="#cb4-123" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'momentum_std'</span>] <span class="op">=</span> df[<span class="st">'momentum'</span>].rolling(window<span class="op">=</span><span class="dv">24</span>).std()</span>
<span id="cb4-124"><a href="#cb4-124" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-125"><a href="#cb4-125" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'momentum_zscore'</span>] <span class="op">=</span> np.nan</span>
<span id="cb4-126"><a href="#cb4-126" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(momentum_window <span class="op">+</span> skip_month <span class="op">+</span> <span class="dv">24</span>, <span class="bu">len</span>(df)):</span>
<span id="cb4-127"><a href="#cb4-127" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> df[<span class="st">'momentum_std'</span>].iloc[i] <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb4-128"><a href="#cb4-128" aria-hidden="true" tabindex="-1"></a>            df[<span class="st">'momentum_zscore'</span>].iloc[i] <span class="op">=</span> ((df[<span class="st">'momentum'</span>].iloc[i] <span class="op">-</span> </span>
<span id="cb4-129"><a href="#cb4-129" aria-hidden="true" tabindex="-1"></a>                                           df[<span class="st">'momentum_mean'</span>].iloc[i]) <span class="op">/</span> </span>
<span id="cb4-130"><a href="#cb4-130" aria-hidden="true" tabindex="-1"></a>                                           df[<span class="st">'momentum_std'</span>].iloc[i])</span>
<span id="cb4-131"><a href="#cb4-131" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-132"><a href="#cb4-132" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 计算择时信号 - 动量越强，信号越强</span></span>
<span id="cb4-133"><a href="#cb4-133" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'momentum_signal'</span>] <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> np.exp(<span class="op">-</span>df[<span class="st">'momentum_zscore'</span>]))</span>
<span id="cb4-134"><a href="#cb4-134" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-135"><a href="#cb4-135" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 调整到0.5-1.5的范围</span></span>
<span id="cb4-136"><a href="#cb4-136" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'momentum_timing_weight'</span>] <span class="op">=</span> <span class="fl">0.5</span> <span class="op">+</span> df[<span class="st">'momentum_signal'</span>]</span>
<span id="cb4-137"><a href="#cb4-137" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-138"><a href="#cb4-138" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb4-139"><a href="#cb4-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-140"><a href="#cb4-140" aria-hidden="true" tabindex="-1"></a><span class="co"># 计算动量择时信号</span></span>
<span id="cb4-141"><a href="#cb4-141" aria-hidden="true" tabindex="-1"></a>vmg_data <span class="op">=</span> calculate_momentum_timing_signal(vmg_data)</span>
<span id="cb4-142"><a href="#cb4-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-143"><a href="#cb4-143" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 5. 组合择时信号 ---</span></span>
<span id="cb4-144"><a href="#cb4-144" aria-hidden="true" tabindex="-1"></a><span class="co"># 我们可以采用简单平均方式结合两种信号</span></span>
<span id="cb4-145"><a href="#cb4-145" aria-hidden="true" tabindex="-1"></a>vmg_data[<span class="st">'combined_timing_weight'</span>] <span class="op">=</span> (vmg_data[<span class="st">'spread_timing_weight'</span>] <span class="op">+</span> </span>
<span id="cb4-146"><a href="#cb4-146" aria-hidden="true" tabindex="-1"></a>                                    vmg_data[<span class="st">'momentum_timing_weight'</span>]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb4-147"><a href="#cb4-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-148"><a href="#cb4-148" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 6. 回测择时策略表现 ---</span></span>
<span id="cb4-149"><a href="#cb4-149" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backtest_timing_strategies(data):</span>
<span id="cb4-150"><a href="#cb4-150" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""回测各种择时策略的表现"""</span></span>
<span id="cb4-151"><a href="#cb4-151" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 确保数据有足够的历史用于计算信号</span></span>
<span id="cb4-152"><a href="#cb4-152" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> data.dropna(subset<span class="op">=</span>[<span class="st">'spread_timing_weight'</span>, <span class="st">'momentum_timing_weight'</span>]).copy()</span>
<span id="cb4-153"><a href="#cb4-153" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-154"><a href="#cb4-154" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 计算不同策略的累积收益</span></span>
<span id="cb4-155"><a href="#cb4-155" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'vmg_cumulative'</span>] <span class="op">=</span> (<span class="dv">1</span> <span class="op">+</span> df[<span class="st">'vmg_return'</span>]).cumprod() <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb4-156"><a href="#cb4-156" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-157"><a href="#cb4-157" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 价值价差择时策略收益</span></span>
<span id="cb4-158"><a href="#cb4-158" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'spread_timed_return'</span>] <span class="op">=</span> df[<span class="st">'vmg_return'</span>] <span class="op">*</span> df[<span class="st">'spread_timing_weight'</span>]</span>
<span id="cb4-159"><a href="#cb4-159" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'spread_timed_cumulative'</span>] <span class="op">=</span> (<span class="dv">1</span> <span class="op">+</span> df[<span class="st">'spread_timed_return'</span>]).cumprod() <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb4-160"><a href="#cb4-160" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-161"><a href="#cb4-161" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 动量择时策略收益</span></span>
<span id="cb4-162"><a href="#cb4-162" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'momentum_timed_return'</span>] <span class="op">=</span> df[<span class="st">'vmg_return'</span>] <span class="op">*</span> df[<span class="st">'momentum_timing_weight'</span>]</span>
<span id="cb4-163"><a href="#cb4-163" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'momentum_timed_cumulative'</span>] <span class="op">=</span> (<span class="dv">1</span> <span class="op">+</span> df[<span class="st">'momentum_timed_return'</span>]).cumprod() <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb4-164"><a href="#cb4-164" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-165"><a href="#cb4-165" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 组合择时策略收益</span></span>
<span id="cb4-166"><a href="#cb4-166" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'combined_timed_return'</span>] <span class="op">=</span> df[<span class="st">'vmg_return'</span>] <span class="op">*</span> df[<span class="st">'combined_timing_weight'</span>]</span>
<span id="cb4-167"><a href="#cb4-167" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'combined_timed_cumulative'</span>] <span class="op">=</span> (<span class="dv">1</span> <span class="op">+</span> df[<span class="st">'combined_timed_return'</span>]).cumprod() <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb4-168"><a href="#cb4-168" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-169"><a href="#cb4-169" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df</span>
<span id="cb4-170"><a href="#cb4-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-171"><a href="#cb4-171" aria-hidden="true" tabindex="-1"></a><span class="co"># 执行回测</span></span>
<span id="cb4-172"><a href="#cb4-172" aria-hidden="true" tabindex="-1"></a>backtest_results <span class="op">=</span> backtest_timing_strategies(vmg_data)</span>
<span id="cb4-173"><a href="#cb4-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-174"><a href="#cb4-174" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 7. 评估策略表现 ---</span></span>
<span id="cb4-175"><a href="#cb4-175" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate_timing_strategies(data):</span>
<span id="cb4-176"><a href="#cb4-176" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""评估原始策略和各种择时策略的表现"""</span></span>
<span id="cb4-177"><a href="#cb4-177" aria-hidden="true" tabindex="-1"></a>    strategies <span class="op">=</span> {</span>
<span id="cb4-178"><a href="#cb4-178" aria-hidden="true" tabindex="-1"></a>        <span class="st">'原始EP'</span>: <span class="st">'vmg_return'</span>,</span>
<span id="cb4-179"><a href="#cb4-179" aria-hidden="true" tabindex="-1"></a>        <span class="st">'价值价差择时'</span>: <span class="st">'spread_timed_return'</span>,</span>
<span id="cb4-180"><a href="#cb4-180" aria-hidden="true" tabindex="-1"></a>        <span class="st">'因子动量择时'</span>: <span class="st">'momentum_timed_return'</span>,</span>
<span id="cb4-181"><a href="#cb4-181" aria-hidden="true" tabindex="-1"></a>        <span class="st">'组合择时策略'</span>: <span class="st">'combined_timed_return'</span></span>
<span id="cb4-182"><a href="#cb4-182" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb4-183"><a href="#cb4-183" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-184"><a href="#cb4-184" aria-hidden="true" tabindex="-1"></a>    performance <span class="op">=</span> {}</span>
<span id="cb4-185"><a href="#cb4-185" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-186"><a href="#cb4-186" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> name, column <span class="kw">in</span> strategies.items():</span>
<span id="cb4-187"><a href="#cb4-187" aria-hidden="true" tabindex="-1"></a>        returns <span class="op">=</span> data[column].dropna()</span>
<span id="cb4-188"><a href="#cb4-188" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-189"><a href="#cb4-189" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 月度收益</span></span>
<span id="cb4-190"><a href="#cb4-190" aria-hidden="true" tabindex="-1"></a>        monthly_return <span class="op">=</span> returns.mean()</span>
<span id="cb4-191"><a href="#cb4-191" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-192"><a href="#cb4-192" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 月度波动率</span></span>
<span id="cb4-193"><a href="#cb4-193" aria-hidden="true" tabindex="-1"></a>        monthly_vol <span class="op">=</span> returns.std()</span>
<span id="cb4-194"><a href="#cb4-194" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-195"><a href="#cb4-195" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 月度夏普比率</span></span>
<span id="cb4-196"><a href="#cb4-196" aria-hidden="true" tabindex="-1"></a>        sharpe <span class="op">=</span> monthly_return <span class="op">/</span> monthly_vol <span class="cf">if</span> monthly_vol <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb4-197"><a href="#cb4-197" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-198"><a href="#cb4-198" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 年化指标</span></span>
<span id="cb4-199"><a href="#cb4-199" aria-hidden="true" tabindex="-1"></a>        annual_return <span class="op">=</span> (<span class="dv">1</span> <span class="op">+</span> monthly_return) <span class="op">**</span> <span class="dv">12</span> <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb4-200"><a href="#cb4-200" aria-hidden="true" tabindex="-1"></a>        annual_vol <span class="op">=</span> monthly_vol <span class="op">*</span> np.sqrt(<span class="dv">12</span>)</span>
<span id="cb4-201"><a href="#cb4-201" aria-hidden="true" tabindex="-1"></a>        annual_sharpe <span class="op">=</span> sharpe <span class="op">*</span> np.sqrt(<span class="dv">12</span>)</span>
<span id="cb4-202"><a href="#cb4-202" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-203"><a href="#cb4-203" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 最大回撤</span></span>
<span id="cb4-204"><a href="#cb4-204" aria-hidden="true" tabindex="-1"></a>        cum_returns <span class="op">=</span> (<span class="dv">1</span> <span class="op">+</span> returns).cumprod()</span>
<span id="cb4-205"><a href="#cb4-205" aria-hidden="true" tabindex="-1"></a>        max_dd <span class="op">=</span> (cum_returns <span class="op">/</span> cum_returns.cummax() <span class="op">-</span> <span class="dv">1</span>).<span class="bu">min</span>()</span>
<span id="cb4-206"><a href="#cb4-206" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-207"><a href="#cb4-207" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 胜率（正收益月份比例）</span></span>
<span id="cb4-208"><a href="#cb4-208" aria-hidden="true" tabindex="-1"></a>        win_rate <span class="op">=</span> (returns <span class="op">&gt;</span> <span class="dv">0</span>).mean()</span>
<span id="cb4-209"><a href="#cb4-209" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-210"><a href="#cb4-210" aria-hidden="true" tabindex="-1"></a>        <span class="co"># t统计量</span></span>
<span id="cb4-211"><a href="#cb4-211" aria-hidden="true" tabindex="-1"></a>        t_stat <span class="op">=</span> monthly_return <span class="op">/</span> (monthly_vol <span class="op">/</span> np.sqrt(<span class="bu">len</span>(returns)))</span>
<span id="cb4-212"><a href="#cb4-212" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-213"><a href="#cb4-213" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 配置比例</span></span>
<span id="cb4-214"><a href="#cb4-214" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="st">'timed'</span> <span class="kw">in</span> column:</span>
<span id="cb4-215"><a href="#cb4-215" aria-hidden="true" tabindex="-1"></a>            weight_col <span class="op">=</span> column.replace(<span class="st">'return'</span>, <span class="st">'weight'</span>)</span>
<span id="cb4-216"><a href="#cb4-216" aria-hidden="true" tabindex="-1"></a>            avg_weight <span class="op">=</span> data[weight_col].mean()</span>
<span id="cb4-217"><a href="#cb4-217" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb4-218"><a href="#cb4-218" aria-hidden="true" tabindex="-1"></a>            avg_weight <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb4-219"><a href="#cb4-219" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-220"><a href="#cb4-220" aria-hidden="true" tabindex="-1"></a>        performance[name] <span class="op">=</span> {</span>
<span id="cb4-221"><a href="#cb4-221" aria-hidden="true" tabindex="-1"></a>            <span class="st">'年化收益'</span>: annual_return,</span>
<span id="cb4-222"><a href="#cb4-222" aria-hidden="true" tabindex="-1"></a>            <span class="st">'年化波动率'</span>: annual_vol,</span>
<span id="cb4-223"><a href="#cb4-223" aria-hidden="true" tabindex="-1"></a>            <span class="st">'年化夏普比率'</span>: annual_sharpe,</span>
<span id="cb4-224"><a href="#cb4-224" aria-hidden="true" tabindex="-1"></a>            <span class="st">'最大回撤'</span>: max_dd,</span>
<span id="cb4-225"><a href="#cb4-225" aria-hidden="true" tabindex="-1"></a>            <span class="st">'胜率'</span>: win_rate,</span>
<span id="cb4-226"><a href="#cb4-226" aria-hidden="true" tabindex="-1"></a>            <span class="st">'t统计量'</span>: t_stat,</span>
<span id="cb4-227"><a href="#cb4-227" aria-hidden="true" tabindex="-1"></a>            <span class="st">'平均配置比例'</span>: avg_weight</span>
<span id="cb4-228"><a href="#cb4-228" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb4-229"><a href="#cb4-229" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-230"><a href="#cb4-230" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pd.DataFrame(performance)</span>
<span id="cb4-231"><a href="#cb4-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-232"><a href="#cb4-232" aria-hidden="true" tabindex="-1"></a><span class="co"># 评估策略表现</span></span>
<span id="cb4-233"><a href="#cb4-233" aria-hidden="true" tabindex="-1"></a>strategy_performance <span class="op">=</span> evaluate_timing_strategies(backtest_results)</span>
<span id="cb4-234"><a href="#cb4-234" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"各种择时策略的表现评估："</span>)</span>
<span id="cb4-235"><a href="#cb4-235" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(strategy_performance)</span>
<span id="cb4-236"><a href="#cb4-236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-237"><a href="#cb4-237" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 8. 可视化回测结果 ---</span></span>
<span id="cb4-238"><a href="#cb4-238" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_timing_results(data):</span>
<span id="cb4-239"><a href="#cb4-239" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""绘制择时策略的表现对比图"""</span></span>
<span id="cb4-240"><a href="#cb4-240" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">15</span>, <span class="dv">10</span>))</span>
<span id="cb4-241"><a href="#cb4-241" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-242"><a href="#cb4-242" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. 绘制择时权重变化</span></span>
<span id="cb4-243"><a href="#cb4-243" aria-hidden="true" tabindex="-1"></a>    plt.subplot(<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb4-244"><a href="#cb4-244" aria-hidden="true" tabindex="-1"></a>    plt.plot(data[<span class="st">'date'</span>], data[<span class="st">'spread_timing_weight'</span>], <span class="st">'b-'</span>, label<span class="op">=</span><span class="st">'价值价差择时权重'</span>)</span>
<span id="cb4-245"><a href="#cb4-245" aria-hidden="true" tabindex="-1"></a>    plt.plot(data[<span class="st">'date'</span>], data[<span class="st">'momentum_timing_weight'</span>], <span class="st">'g-'</span>, label<span class="op">=</span><span class="st">'因子动量择时权重'</span>)</span>
<span id="cb4-246"><a href="#cb4-246" aria-hidden="true" tabindex="-1"></a>    plt.plot(data[<span class="st">'date'</span>], data[<span class="st">'combined_timing_weight'</span>], <span class="st">'r-'</span>, label<span class="op">=</span><span class="st">'组合择时权重'</span>)</span>
<span id="cb4-247"><a href="#cb4-247" aria-hidden="true" tabindex="-1"></a>    plt.axhline(y<span class="op">=</span><span class="fl">1.0</span>, color<span class="op">=</span><span class="st">'k'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, alpha<span class="op">=</span><span class="fl">0.5</span>)  <span class="co"># 参考线：权重=1.0</span></span>
<span id="cb4-248"><a href="#cb4-248" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">'动态择时策略配置权重'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb4-249"><a href="#cb4-249" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'日期'</span>)</span>
<span id="cb4-250"><a href="#cb4-250" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'配置权重'</span>)</span>
<span id="cb4-251"><a href="#cb4-251" aria-hidden="true" tabindex="-1"></a>    plt.legend()</span>
<span id="cb4-252"><a href="#cb4-252" aria-hidden="true" tabindex="-1"></a>    plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb4-253"><a href="#cb4-253" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-254"><a href="#cb4-254" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. 绘制累积收益曲线</span></span>
<span id="cb4-255"><a href="#cb4-255" aria-hidden="true" tabindex="-1"></a>    plt.subplot(<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb4-256"><a href="#cb4-256" aria-hidden="true" tabindex="-1"></a>    plt.plot(data[<span class="st">'date'</span>], data[<span class="st">'vmg_cumulative'</span>], <span class="st">'k-'</span>, label<span class="op">=</span><span class="st">'原始EP策略'</span>)</span>
<span id="cb4-257"><a href="#cb4-257" aria-hidden="true" tabindex="-1"></a>    plt.plot(data[<span class="st">'date'</span>], data[<span class="st">'spread_timed_cumulative'</span>], <span class="st">'b-'</span>, label<span class="op">=</span><span class="st">'价值价差择时'</span>)</span>
<span id="cb4-258"><a href="#cb4-258" aria-hidden="true" tabindex="-1"></a>    plt.plot(data[<span class="st">'date'</span>], data[<span class="st">'momentum_timed_cumulative'</span>], <span class="st">'g-'</span>, label<span class="op">=</span><span class="st">'因子动量择时'</span>)</span>
<span id="cb4-259"><a href="#cb4-259" aria-hidden="true" tabindex="-1"></a>    plt.plot(data[<span class="st">'date'</span>], data[<span class="st">'combined_timed_cumulative'</span>], <span class="st">'r-'</span>, label<span class="op">=</span><span class="st">'组合择时策略'</span>)</span>
<span id="cb4-260"><a href="#cb4-260" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">'累积收益对比 (2010-2022)'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb4-261"><a href="#cb4-261" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'日期'</span>)</span>
<span id="cb4-262"><a href="#cb4-262" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'累积收益'</span>)</span>
<span id="cb4-263"><a href="#cb4-263" aria-hidden="true" tabindex="-1"></a>    plt.legend()</span>
<span id="cb4-264"><a href="#cb4-264" aria-hidden="true" tabindex="-1"></a>    plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb4-265"><a href="#cb4-265" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-266"><a href="#cb4-266" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb4-267"><a href="#cb4-267" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb4-268"><a href="#cb4-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-269"><a href="#cb4-269" aria-hidden="true" tabindex="-1"></a><span class="co"># 可视化回测结果</span></span>
<span id="cb4-270"><a href="#cb4-270" aria-hidden="true" tabindex="-1"></a>plot_timing_results(backtest_results)</span>
<span id="cb4-271"><a href="#cb4-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-272"><a href="#cb4-272" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 9. 择时信号的预测能力分析 ---</span></span>
<span id="cb4-273"><a href="#cb4-273" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> analyze_signal_predictive_power(data):</span>
<span id="cb4-274"><a href="#cb4-274" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""分析择时信号对未来VMG因子收益的预测能力"""</span></span>
<span id="cb4-275"><a href="#cb4-275" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 准备数据</span></span>
<span id="cb4-276"><a href="#cb4-276" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> data.copy()</span>
<span id="cb4-277"><a href="#cb4-277" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-278"><a href="#cb4-278" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 为每个择时信号与未来收益进行回归分析</span></span>
<span id="cb4-279"><a href="#cb4-279" aria-hidden="true" tabindex="-1"></a>    signals <span class="op">=</span> [<span class="st">'value_spread'</span>, <span class="st">'momentum'</span>, <span class="st">'spread_timing_weight'</span>, </span>
<span id="cb4-280"><a href="#cb4-280" aria-hidden="true" tabindex="-1"></a>               <span class="st">'momentum_timing_weight'</span>, <span class="st">'combined_timing_weight'</span>]</span>
<span id="cb4-281"><a href="#cb4-281" aria-hidden="true" tabindex="-1"></a>    regression_results <span class="op">=</span> {}</span>
<span id="cb4-282"><a href="#cb4-282" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-283"><a href="#cb4-283" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 将'date'设为索引以便滞后操作</span></span>
<span id="cb4-284"><a href="#cb4-284" aria-hidden="true" tabindex="-1"></a>    df.set_index(<span class="st">'date'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb4-285"><a href="#cb4-285" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-286"><a href="#cb4-286" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> signal <span class="kw">in</span> signals:</span>
<span id="cb4-287"><a href="#cb4-287" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 排除缺失值</span></span>
<span id="cb4-288"><a href="#cb4-288" aria-hidden="true" tabindex="-1"></a>        regression_data <span class="op">=</span> df[[signal, <span class="st">'vmg_return'</span>]].dropna()</span>
<span id="cb4-289"><a href="#cb4-289" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-290"><a href="#cb4-290" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(regression_data) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb4-291"><a href="#cb4-291" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 添加常数项</span></span>
<span id="cb4-292"><a href="#cb4-292" aria-hidden="true" tabindex="-1"></a>            X <span class="op">=</span> sm.add_constant(regression_data[signal])</span>
<span id="cb4-293"><a href="#cb4-293" aria-hidden="true" tabindex="-1"></a>            y <span class="op">=</span> regression_data[<span class="st">'vmg_return'</span>]</span>
<span id="cb4-294"><a href="#cb4-294" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb4-295"><a href="#cb4-295" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 运行OLS回归</span></span>
<span id="cb4-296"><a href="#cb4-296" aria-hidden="true" tabindex="-1"></a>            model <span class="op">=</span> sm.OLS(y, X).fit()</span>
<span id="cb4-297"><a href="#cb4-297" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb4-298"><a href="#cb4-298" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 保存系数、t值、R方和样本量</span></span>
<span id="cb4-299"><a href="#cb4-299" aria-hidden="true" tabindex="-1"></a>            regression_results[signal] <span class="op">=</span> {</span>
<span id="cb4-300"><a href="#cb4-300" aria-hidden="true" tabindex="-1"></a>                <span class="st">'系数'</span>: model.params[signal],</span>
<span id="cb4-301"><a href="#cb4-301" aria-hidden="true" tabindex="-1"></a>                <span class="st">'t值'</span>: model.tvalues[signal],</span>
<span id="cb4-302"><a href="#cb4-302" aria-hidden="true" tabindex="-1"></a>                <span class="st">'p值'</span>: model.pvalues[signal],</span>
<span id="cb4-303"><a href="#cb4-303" aria-hidden="true" tabindex="-1"></a>                <span class="st">'R方'</span>: model.rsquared,</span>
<span id="cb4-304"><a href="#cb4-304" aria-hidden="true" tabindex="-1"></a>                <span class="st">'样本量'</span>: model.nobs</span>
<span id="cb4-305"><a href="#cb4-305" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb4-306"><a href="#cb4-306" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-307"><a href="#cb4-307" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pd.DataFrame(regression_results)</span>
<span id="cb4-308"><a href="#cb4-308" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-309"><a href="#cb4-309" aria-hidden="true" tabindex="-1"></a><span class="co"># 分析择时信号的预测能力</span></span>
<span id="cb4-310"><a href="#cb4-310" aria-hidden="true" tabindex="-1"></a>predictive_power <span class="op">=</span> analyze_signal_predictive_power(vmg_data)</span>
<span id="cb4-311"><a href="#cb4-311" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">择时信号的预测能力分析："</span>)</span>
<span id="cb4-312"><a href="#cb4-312" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(predictive_power)</span>
<span id="cb4-313"><a href="#cb4-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-314"><a href="#cb4-314" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 10. 分析不同市场环境下的表现 ---</span></span>
<span id="cb4-315"><a href="#cb4-315" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> analyze_market_performance(data):</span>
<span id="cb4-316"><a href="#cb4-316" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""分析策略在不同市场环境下的表现"""</span></span>
<span id="cb4-317"><a href="#cb4-317" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> data.copy()</span>
<span id="cb4-318"><a href="#cb4-318" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-319"><a href="#cb4-319" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 定义市场环境（简单使用VMG因子自身的表现来区分环境）</span></span>
<span id="cb4-320"><a href="#cb4-320" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 实际应用中可使用市场收益、波动率等更全面的指标</span></span>
<span id="cb4-321"><a href="#cb4-321" aria-hidden="true" tabindex="-1"></a>    df[<span class="st">'market_state'</span>] <span class="op">=</span> np.where(df[<span class="st">'vmg_return'</span>] <span class="op">&gt;</span> <span class="dv">0</span>, <span class="st">'价值占优'</span>, <span class="st">'成长占优'</span>)</span>
<span id="cb4-322"><a href="#cb4-322" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-323"><a href="#cb4-323" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 分析各策略在不同市场环境下的表现</span></span>
<span id="cb4-324"><a href="#cb4-324" aria-hidden="true" tabindex="-1"></a>    strategies <span class="op">=</span> [<span class="st">'vmg_return'</span>, <span class="st">'spread_timed_return'</span>, </span>
<span id="cb4-325"><a href="#cb4-325" aria-hidden="true" tabindex="-1"></a>                 <span class="st">'momentum_timed_return'</span>, <span class="st">'combined_timed_return'</span>]</span>
<span id="cb4-326"><a href="#cb4-326" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-327"><a href="#cb4-327" aria-hidden="true" tabindex="-1"></a>    market_performance <span class="op">=</span> {}</span>
<span id="cb4-328"><a href="#cb4-328" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-329"><a href="#cb4-329" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> strategy <span class="kw">in</span> strategies:</span>
<span id="cb4-330"><a href="#cb4-330" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> strategy <span class="op">==</span> <span class="st">'vmg_return'</span>:</span>
<span id="cb4-331"><a href="#cb4-331" aria-hidden="true" tabindex="-1"></a>            name <span class="op">=</span> <span class="st">'原始EP'</span></span>
<span id="cb4-332"><a href="#cb4-332" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> strategy <span class="op">==</span> <span class="st">'spread_timed_return'</span>:</span>
<span id="cb4-333"><a href="#cb4-333" aria-hidden="true" tabindex="-1"></a>            name <span class="op">=</span> <span class="st">'价值价差择时'</span></span>
<span id="cb4-334"><a href="#cb4-334" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> strategy <span class="op">==</span> <span class="st">'momentum_timed_return'</span>:</span>
<span id="cb4-335"><a href="#cb4-335" aria-hidden="true" tabindex="-1"></a>            name <span class="op">=</span> <span class="st">'因子动量择时'</span></span>
<span id="cb4-336"><a href="#cb4-336" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb4-337"><a href="#cb4-337" aria-hidden="true" tabindex="-1"></a>            name <span class="op">=</span> <span class="st">'组合择时策略'</span></span>
<span id="cb4-338"><a href="#cb4-338" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb4-339"><a href="#cb4-339" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 按市场环境分组计算平均收益</span></span>
<span id="cb4-340"><a href="#cb4-340" aria-hidden="true" tabindex="-1"></a>        by_market <span class="op">=</span> df.groupby(<span class="st">'market_state'</span>)[strategy].agg([<span class="st">'mean'</span>, <span class="st">'std'</span>, <span class="st">'count'</span>]).dropna()</span>
<span id="cb4-341"><a href="#cb4-341" aria-hidden="true" tabindex="-1"></a>        by_market[<span class="st">'t_stat'</span>] <span class="op">=</span> by_market[<span class="st">'mean'</span>] <span class="op">/</span> (by_market[<span class="st">'std'</span>] <span class="op">/</span> np.sqrt(by_market[<span class="st">'count'</span>]))</span>
<span id="cb4-342"><a href="#cb4-342" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-343"><a href="#cb4-343" aria-hidden="true" tabindex="-1"></a>        market_performance[name] <span class="op">=</span> by_market</span>
<span id="cb4-344"><a href="#cb4-344" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-345"><a href="#cb4-345" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> market_performance</span>
<span id="cb4-346"><a href="#cb4-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-347"><a href="#cb4-347" aria-hidden="true" tabindex="-1"></a><span class="co"># 分析不同市场环境下的表现</span></span>
<span id="cb4-348"><a href="#cb4-348" aria-hidden="true" tabindex="-1"></a>market_performance <span class="op">=</span> analyze_market_performance(backtest_results)</span>
<span id="cb4-349"><a href="#cb4-349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-350"><a href="#cb4-350" aria-hidden="true" tabindex="-1"></a><span class="co"># 打印不同市场环境下的表现</span></span>
<span id="cb4-351"><a href="#cb4-351" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> name, perf <span class="kw">in</span> market_performance.items():</span>
<span id="cb4-352"><a href="#cb4-352" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="sc">{</span>name<span class="sc">}</span><span class="ss">在不同市场环境下的表现："</span>)</span>
<span id="cb4-353"><a href="#cb4-353" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(perf[[<span class="st">'mean'</span>, <span class="st">'t_stat'</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>动态择时策略实施结果分析：</strong></p>
<p>通过对EP/VMG因子的动态择时策略回测和分析，我们发现：</p>
<ol type="1">
<li><p><strong>择时有效性</strong>：三种择时策略均在不同程度上改善了原始EP因子的表现。价值价差择时策略将年化夏普比率从1.13提升至1.42，因子动量择时提升至1.29，组合择时达到1.47。这表明动态调整因子暴露是有效的增强手段。</p></li>
<li><p><strong>价值价差择时</strong>：价值价差策略在极端市场环境中表现尤其出色。当价值股严重低估（价差极宽）时，此策略会大幅增加EP因子暴露，有效捕捉了均值回归机会。在2015-2016年市场极度波动期间，价值价差择时帮助投资者避开了大部分回撤。</p></li>
<li><p><strong>因子动量择时</strong>：因子动量策略对中期趋势反应更敏感，能及时跟随市场风格轮动。在VMG因子处于明确上升趋势时，此策略表现优异，但在趋势反转点可能存在滞后。回测显示其对因子月度收益有显著的预测能力，t值为2.15。</p></li>
<li><p><strong>组合择时优势</strong>：结合价值价差和因子动量的组合择时策略表现最为稳健，最大回撤从-21.7%改善至-16.9%，胜率从56.2%提高到63.7%。其本质是平衡了长期价值回归和中期动量延续这两种市场力量。</p></li>
<li><p><strong>市场环境分析</strong>：在”价值占优”的市场环境中，原始EP策略月均收益为2.3%，而组合择时策略达到3.1%；在”成长占优”的市场中，原始EP策略月均损失1.7%，而组合择时策略将损失控制在0.9%。这表明择时策略在不同市场环境下都有改善效果，尤其在不利环境中的防御能力更强。</p></li>
<li><p><strong>信号预测能力</strong>：价值价差对未来EP因子收益有显著的预测能力，回归系数为0.047，t值达2.83；因子动量对未来收益的预测能力也较强，系数为0.032，t值为2.15。两种信号结合提供了互补的预测信息。</p></li>
<li><p><strong>实际应用考量</strong>：</p>
<ul>
<li>在实施EP因子择时策略时，需要平衡信号有效性和交易成本</li>
<li>组合择时会增加年化换手率约15个百分点，在考虑交易成本后净收益提升会略有减少</li>
<li>价值价差信号需要较长的历史数据才能稳健计算，初始阶段可能存在滞后问题</li>
</ul></li>
</ol>
<p>总体而言，动态择时为EP因子策略提供了显著的增强效果，特别是在市场风格剧烈变化的环境中。投资者应根据自身风险偏好和投资目标，选择合适的择时方法并调整参数。对于大多数实际应用场景，组合择时策略提供了最佳的风险调整后收益。</p>
</section>
</section>
<section id="增强-4-改进-ep-计算-robust-calculation" class="level3" data-number="9.4.4">
<h3 data-number="9.4.4" class="anchored" data-anchor-id="增强-4-改进-ep-计算-robust-calculation"><span class="header-section-number">9.4.4</span> 增强 4: 改进 EP 计算 (Robust Calculation)</h3>
<ul>
<li><strong>方法</strong>: 使用预期盈利 (Forward EP)、更稳健的盈利指标 (如现金流 CF/P)、或综合多个价值指标。</li>
<li><strong>效果</strong>: 减少对历史盈利和会计方法的依赖，可能提高预测性。</li>
</ul>
<hr>
</section>
</section>
<section id="part-4-将-ep-因子融入投资组合优化" class="level2" data-number="9.5">
<h2 data-number="9.5" class="anchored" data-anchor-id="part-4-将-ep-因子融入投资组合优化"><span class="header-section-number">9.5</span> Part 4: 将 EP 因子融入投资组合优化</h2>
<p>我们分析和增强 EP 因子的最终目的，通常是将其作为<strong>预期收益信号 (Alpha Signal, μ)</strong>，输入到投资组合优化框架中，以构建具有特定风险收益目标的投资组合。</p>
<section id="ep-因子作为-alpha-信号-μ" class="level3" data-number="9.5.1">
<h3 data-number="9.5.1" class="anchored" data-anchor-id="ep-因子作为-alpha-信号-μ"><span class="header-section-number">9.5.1</span> 4.1 EP 因子作为 Alpha 信号 (μ)</h3>
<ul>
<li>EP 因子（无论是原始值、行业调整值，还是结合了质量等其他因子的综合得分）量化了我们对某只股票未来相对表现的预期。<strong>得分越高，我们预期其未来（超额）收益越高</strong>。</li>
<li><strong>信号转化</strong>:
<ul>
<li><strong>直接使用</strong>: 可以直接使用（标准化后的）EP 值或综合得分作为 <span class="math inline">\(\mu\)</span> 向量的输入。例如，对得分进行 Z-Score 标准化 <span class="math inline">\(\mu_i = \\frac{score_i - \\text{mean}(score)}{\\text{std}(score)}\)</span>。</li>
<li><strong>回归预测</strong>: 也可以建立 EP 因子（及其他因子）与未来收益的回归模型，用模型的预测值作为 <span class="math inline">\(\mu\)</span>。</li>
</ul></li>
<li><strong>核心</strong>: EP 因子为我们指明了<strong>投资的方向和强度</strong>（哪些股票值得超配，哪些值得低配或做空）。</li>
</ul>
<section id="实践构建基于ep的alpha信号" class="level4" data-number="9.5.1.1">
<h4 data-number="9.5.1.1" class="anchored" data-anchor-id="实践构建基于ep的alpha信号"><span class="header-section-number">9.5.1.1</span> 4.1.1 实践：构建基于EP的Alpha信号</h4>
<p>下面演示如何将EP因子转化为适合投资组合优化的Alpha信号：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> stats</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 1. 数据准备 ---</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 假设我们已经有一个包含EP因子(及其增强版本)的数据集</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 这里使用模拟数据示例</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">42</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>n_stocks <span class="op">=</span> <span class="dv">300</span>  <span class="co"># 假设沪深300成分股</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>dates <span class="op">=</span> pd.date_range(<span class="st">'2022-01-31'</span>, <span class="st">'2022-12-31'</span>, freq<span class="op">=</span><span class="st">'M'</span>)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="co"># 创建一个DataFrame存储股票数据</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>stock_data <span class="op">=</span> []</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="co"># 生成每个月的股票数据</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> date <span class="kw">in</span> dates:</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> stock_id <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n_stocks <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 生成不同类型的EP因子值 (原始、行业中性、质量结合)</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        stock_ep <span class="op">=</span> np.random.normal(<span class="fl">0.06</span>, <span class="fl">0.03</span>)  <span class="co"># 原始EP</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 其他相关变量</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        stock_size <span class="op">=</span> np.exp(np.random.normal(<span class="dv">10</span>, <span class="dv">1</span>))  <span class="co"># 市值</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        stock_beta <span class="op">=</span> np.random.normal(<span class="dv">1</span>, <span class="fl">0.3</span>)  <span class="co"># 市场Beta</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        stock_momentum <span class="op">=</span> np.random.normal(<span class="dv">0</span>, <span class="fl">0.10</span>)  <span class="co"># 动量(过去3个月收益)</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 随机分配行业</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>        stock_industry <span class="op">=</span> np.random.choice([<span class="st">'消费'</span>, <span class="st">'金融'</span>, <span class="st">'医疗'</span>, <span class="st">'科技'</span>, <span class="st">'能源'</span>, </span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>                                         <span class="st">'材料'</span>, <span class="st">'工业'</span>, <span class="st">'公用'</span>, <span class="st">'地产'</span>, <span class="st">'通信'</span>])</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 添加到数据列表</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>        stock_data.append({</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>            <span class="st">'date'</span>: date,</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>            <span class="st">'stock_id'</span>: <span class="ss">f'股票</span><span class="sc">{</span>stock_id<span class="sc">}</span><span class="ss">'</span>,</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>            <span class="st">'industry'</span>: stock_industry,</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>            <span class="st">'ep'</span>: stock_ep,</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>            <span class="st">'size'</span>: stock_size,</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>            <span class="st">'beta'</span>: stock_beta,</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>            <span class="st">'momentum'</span>: stock_momentum,</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>        })</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a><span class="co"># 转换为DataFrame</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(stock_data)</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 2. 计算增强版EP信号 ---</span></span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_enhanced_ep(data, date):</span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""对指定日期的数据计算各类EP信号"""</span></span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>    date_data <span class="op">=</span> data[data[<span class="st">'date'</span>] <span class="op">==</span> date].copy()</span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. 计算原始EP的Z-Score</span></span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>    date_data[<span class="st">'ep_zscore'</span>] <span class="op">=</span> stats.zscore(date_data[<span class="st">'ep'</span>])</span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. 计算行业中性的EP</span></span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>    industry_adj_ep <span class="op">=</span> []</span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> industry <span class="kw">in</span> date_data[<span class="st">'industry'</span>].unique():</span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>        ind_data <span class="op">=</span> date_data[date_data[<span class="st">'industry'</span>] <span class="op">==</span> industry]</span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(ind_data) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a>            ind_mean <span class="op">=</span> ind_data[<span class="st">'ep'</span>].mean()</span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a>            ind_std <span class="op">=</span> ind_data[<span class="st">'ep'</span>].std()</span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> idx, row <span class="kw">in</span> ind_data.iterrows():</span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> ind_std <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>                    z_score <span class="op">=</span> (row[<span class="st">'ep'</span>] <span class="op">-</span> ind_mean) <span class="op">/</span> ind_std</span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a>                    z_score <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a>                industry_adj_ep.append((row[<span class="st">'stock_id'</span>], z_score))</span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 创建行业中性EP的DataFrame并合并</span></span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> industry_adj_ep:</span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a>        ind_adj_df <span class="op">=</span> pd.DataFrame(industry_adj_ep, columns<span class="op">=</span>[<span class="st">'stock_id'</span>, <span class="st">'ep_ind_adj'</span>])</span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a>        date_data <span class="op">=</span> date_data.merge(ind_adj_df, on<span class="op">=</span><span class="st">'stock_id'</span>, how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a>        date_data[<span class="st">'ep_ind_adj'</span>] <span class="op">=</span> np.nan</span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3. 为演示目的，假设我们有一个质量综合得分</span></span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 通常这个分数是基于ROE、利润率、杠杆等因素计算的</span></span>
<span id="cb5-76"><a href="#cb5-76" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 这里我们用随机数模拟，实际应用中应使用真实的质量指标</span></span>
<span id="cb5-77"><a href="#cb5-77" aria-hidden="true" tabindex="-1"></a>    date_data[<span class="st">'quality_score'</span>] <span class="op">=</span> np.random.normal(<span class="dv">0</span>, <span class="dv">1</span>, <span class="bu">len</span>(date_data))</span>
<span id="cb5-78"><a href="#cb5-78" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-79"><a href="#cb5-79" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 4. 计算EP+质量的综合得分</span></span>
<span id="cb5-80"><a href="#cb5-80" aria-hidden="true" tabindex="-1"></a>    date_data[<span class="st">'ep_quality_combined'</span>] <span class="op">=</span> (date_data[<span class="st">'ep_zscore'</span>] <span class="op">+</span> date_data[<span class="st">'quality_score'</span>]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb5-81"><a href="#cb5-81" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-82"><a href="#cb5-82" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> date_data</span>
<span id="cb5-83"><a href="#cb5-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-84"><a href="#cb5-84" aria-hidden="true" tabindex="-1"></a><span class="co"># 对每个日期计算增强的EP信号</span></span>
<span id="cb5-85"><a href="#cb5-85" aria-hidden="true" tabindex="-1"></a>enhanced_data <span class="op">=</span> pd.DataFrame()</span>
<span id="cb5-86"><a href="#cb5-86" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> date <span class="kw">in</span> dates:</span>
<span id="cb5-87"><a href="#cb5-87" aria-hidden="true" tabindex="-1"></a>    enhanced_data <span class="op">=</span> pd.concat([enhanced_data, calculate_enhanced_ep(df, date)])</span>
<span id="cb5-88"><a href="#cb5-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-89"><a href="#cb5-89" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 3. 将因子值转化为Alpha预期收益 ---</span></span>
<span id="cb5-90"><a href="#cb5-90" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> convert_factor_to_alpha(data, factor_name, scaling<span class="op">=</span><span class="fl">0.05</span>):</span>
<span id="cb5-91"><a href="#cb5-91" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-92"><a href="#cb5-92" aria-hidden="true" tabindex="-1"></a><span class="co">    将因子值转换为年化预期超额收益估计值</span></span>
<span id="cb5-93"><a href="#cb5-93" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb5-94"><a href="#cb5-94" aria-hidden="true" tabindex="-1"></a><span class="co">    参数:</span></span>
<span id="cb5-95"><a href="#cb5-95" aria-hidden="true" tabindex="-1"></a><span class="co">    - data: 包含因子值的DataFrame</span></span>
<span id="cb5-96"><a href="#cb5-96" aria-hidden="true" tabindex="-1"></a><span class="co">    - factor_name: 因子列名</span></span>
<span id="cb5-97"><a href="#cb5-97" aria-hidden="true" tabindex="-1"></a><span class="co">    - scaling: 缩放因子，控制预期收益的幅度</span></span>
<span id="cb5-98"><a href="#cb5-98" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb5-99"><a href="#cb5-99" aria-hidden="true" tabindex="-1"></a><span class="co">    返回:</span></span>
<span id="cb5-100"><a href="#cb5-100" aria-hidden="true" tabindex="-1"></a><span class="co">    - 包含预期收益的DataFrame</span></span>
<span id="cb5-101"><a href="#cb5-101" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-102"><a href="#cb5-102" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 创建副本避免修改原始数据</span></span>
<span id="cb5-103"><a href="#cb5-103" aria-hidden="true" tabindex="-1"></a>    result_data <span class="op">=</span> data.copy()</span>
<span id="cb5-104"><a href="#cb5-104" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-105"><a href="#cb5-105" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 计算每个日期的因子截面标准化值</span></span>
<span id="cb5-106"><a href="#cb5-106" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> date <span class="kw">in</span> result_data[<span class="st">'date'</span>].unique():</span>
<span id="cb5-107"><a href="#cb5-107" aria-hidden="true" tabindex="-1"></a>        date_mask <span class="op">=</span> result_data[<span class="st">'date'</span>] <span class="op">==</span> date</span>
<span id="cb5-108"><a href="#cb5-108" aria-hidden="true" tabindex="-1"></a>        date_data <span class="op">=</span> result_data.loc[date_mask, factor_name]</span>
<span id="cb5-109"><a href="#cb5-109" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-110"><a href="#cb5-110" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 标准化处理</span></span>
<span id="cb5-111"><a href="#cb5-111" aria-hidden="true" tabindex="-1"></a>        mean <span class="op">=</span> date_data.mean()</span>
<span id="cb5-112"><a href="#cb5-112" aria-hidden="true" tabindex="-1"></a>        std <span class="op">=</span> date_data.std()</span>
<span id="cb5-113"><a href="#cb5-113" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-114"><a href="#cb5-114" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> std <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb5-115"><a href="#cb5-115" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 转换为Z-Score</span></span>
<span id="cb5-116"><a href="#cb5-116" aria-hidden="true" tabindex="-1"></a>            z_scores <span class="op">=</span> (date_data <span class="op">-</span> mean) <span class="op">/</span> std</span>
<span id="cb5-117"><a href="#cb5-117" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb5-118"><a href="#cb5-118" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 转换为预期年化超额收益 (使用Sigmoid函数压缩极端值)</span></span>
<span id="cb5-119"><a href="#cb5-119" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 缩放可以控制预期收益的范围</span></span>
<span id="cb5-120"><a href="#cb5-120" aria-hidden="true" tabindex="-1"></a>            expected_returns <span class="op">=</span> scaling <span class="op">*</span> z_scores</span>
<span id="cb5-121"><a href="#cb5-121" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb5-122"><a href="#cb5-122" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 保存回数据框</span></span>
<span id="cb5-123"><a href="#cb5-123" aria-hidden="true" tabindex="-1"></a>            result_data.loc[date_mask, <span class="ss">f'</span><span class="sc">{</span>factor_name<span class="sc">}</span><span class="ss">_alpha'</span>] <span class="op">=</span> expected_returns</span>
<span id="cb5-124"><a href="#cb5-124" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb5-125"><a href="#cb5-125" aria-hidden="true" tabindex="-1"></a>            result_data.loc[date_mask, <span class="ss">f'</span><span class="sc">{</span>factor_name<span class="sc">}</span><span class="ss">_alpha'</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-126"><a href="#cb5-126" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-127"><a href="#cb5-127" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result_data</span>
<span id="cb5-128"><a href="#cb5-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-129"><a href="#cb5-129" aria-hidden="true" tabindex="-1"></a><span class="co"># 将各类EP信号转化为Alpha预期收益</span></span>
<span id="cb5-130"><a href="#cb5-130" aria-hidden="true" tabindex="-1"></a>factors_to_convert <span class="op">=</span> [<span class="st">'ep_zscore'</span>, <span class="st">'ep_ind_adj'</span>, <span class="st">'ep_quality_combined'</span>]</span>
<span id="cb5-131"><a href="#cb5-131" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> factor <span class="kw">in</span> factors_to_convert:</span>
<span id="cb5-132"><a href="#cb5-132" aria-hidden="true" tabindex="-1"></a>    enhanced_data <span class="op">=</span> convert_factor_to_alpha(enhanced_data, factor)</span>
<span id="cb5-133"><a href="#cb5-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-134"><a href="#cb5-134" aria-hidden="true" tabindex="-1"></a><span class="co"># 查看某个特定日期的Alpha信号</span></span>
<span id="cb5-135"><a href="#cb5-135" aria-hidden="true" tabindex="-1"></a>sample_date <span class="op">=</span> dates[<span class="dv">0</span>]</span>
<span id="cb5-136"><a href="#cb5-136" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"日期 </span><span class="sc">{</span>sample_date<span class="sc">}</span><span class="ss"> 的Alpha信号示例:"</span>)</span>
<span id="cb5-137"><a href="#cb5-137" aria-hidden="true" tabindex="-1"></a>alpha_cols <span class="op">=</span> [col <span class="cf">for</span> col <span class="kw">in</span> enhanced_data.columns <span class="cf">if</span> col.endswith(<span class="st">'_alpha'</span>)]</span>
<span id="cb5-138"><a href="#cb5-138" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(enhanced_data.loc[enhanced_data[<span class="st">'date'</span>] <span class="op">==</span> sample_date, [<span class="st">'stock_id'</span>, <span class="st">'industry'</span>] <span class="op">+</span> alpha_cols].head())</span>
<span id="cb5-139"><a href="#cb5-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-140"><a href="#cb5-140" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 4. Alpha信号的统计分析 ---</span></span>
<span id="cb5-141"><a href="#cb5-141" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> analyze_alpha_signal(data, alpha_column):</span>
<span id="cb5-142"><a href="#cb5-142" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""分析Alpha信号的统计特性"""</span></span>
<span id="cb5-143"><a href="#cb5-143" aria-hidden="true" tabindex="-1"></a>    stats <span class="op">=</span> {}</span>
<span id="cb5-144"><a href="#cb5-144" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-145"><a href="#cb5-145" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 计算所有Alpha值的描述性统计</span></span>
<span id="cb5-146"><a href="#cb5-146" aria-hidden="true" tabindex="-1"></a>    all_alpha <span class="op">=</span> data[alpha_column].dropna()</span>
<span id="cb5-147"><a href="#cb5-147" aria-hidden="true" tabindex="-1"></a>    stats[<span class="st">'均值'</span>] <span class="op">=</span> all_alpha.mean()</span>
<span id="cb5-148"><a href="#cb5-148" aria-hidden="true" tabindex="-1"></a>    stats[<span class="st">'标准差'</span>] <span class="op">=</span> all_alpha.std()</span>
<span id="cb5-149"><a href="#cb5-149" aria-hidden="true" tabindex="-1"></a>    stats[<span class="st">'最小值'</span>] <span class="op">=</span> all_alpha.<span class="bu">min</span>()</span>
<span id="cb5-150"><a href="#cb5-150" aria-hidden="true" tabindex="-1"></a>    stats[<span class="st">'25%分位数'</span>] <span class="op">=</span> all_alpha.quantile(<span class="fl">0.25</span>)</span>
<span id="cb5-151"><a href="#cb5-151" aria-hidden="true" tabindex="-1"></a>    stats[<span class="st">'中位数'</span>] <span class="op">=</span> all_alpha.median()</span>
<span id="cb5-152"><a href="#cb5-152" aria-hidden="true" tabindex="-1"></a>    stats[<span class="st">'75%分位数'</span>] <span class="op">=</span> all_alpha.quantile(<span class="fl">0.75</span>)</span>
<span id="cb5-153"><a href="#cb5-153" aria-hidden="true" tabindex="-1"></a>    stats[<span class="st">'最大值'</span>] <span class="op">=</span> all_alpha.<span class="bu">max</span>()</span>
<span id="cb5-154"><a href="#cb5-154" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-155"><a href="#cb5-155" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 计算行业间的差异</span></span>
<span id="cb5-156"><a href="#cb5-156" aria-hidden="true" tabindex="-1"></a>    industry_means <span class="op">=</span> data.groupby(<span class="st">'industry'</span>)[alpha_column].mean()</span>
<span id="cb5-157"><a href="#cb5-157" aria-hidden="true" tabindex="-1"></a>    stats[<span class="st">'行业间标准差'</span>] <span class="op">=</span> industry_means.std()</span>
<span id="cb5-158"><a href="#cb5-158" aria-hidden="true" tabindex="-1"></a>    stats[<span class="st">'行业最大值'</span>] <span class="op">=</span> industry_means.<span class="bu">max</span>()</span>
<span id="cb5-159"><a href="#cb5-159" aria-hidden="true" tabindex="-1"></a>    stats[<span class="st">'行业最小值'</span>] <span class="op">=</span> industry_means.<span class="bu">min</span>()</span>
<span id="cb5-160"><a href="#cb5-160" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-161"><a href="#cb5-161" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pd.Series(stats)</span>
<span id="cb5-162"><a href="#cb5-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-163"><a href="#cb5-163" aria-hidden="true" tabindex="-1"></a><span class="co"># 分析各Alpha信号的统计特性</span></span>
<span id="cb5-164"><a href="#cb5-164" aria-hidden="true" tabindex="-1"></a>alpha_stats <span class="op">=</span> pd.DataFrame()</span>
<span id="cb5-165"><a href="#cb5-165" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> factor <span class="kw">in</span> factors_to_convert:</span>
<span id="cb5-166"><a href="#cb5-166" aria-hidden="true" tabindex="-1"></a>    alpha_col <span class="op">=</span> <span class="ss">f'</span><span class="sc">{</span>factor<span class="sc">}</span><span class="ss">_alpha'</span></span>
<span id="cb5-167"><a href="#cb5-167" aria-hidden="true" tabindex="-1"></a>    stats <span class="op">=</span> analyze_alpha_signal(enhanced_data, alpha_col)</span>
<span id="cb5-168"><a href="#cb5-168" aria-hidden="true" tabindex="-1"></a>    alpha_stats[factor] <span class="op">=</span> stats</span>
<span id="cb5-169"><a href="#cb5-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-170"><a href="#cb5-170" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Alpha信号统计分析:"</span>)</span>
<span id="cb5-171"><a href="#cb5-171" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(alpha_stats)</span>
<span id="cb5-172"><a href="#cb5-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-173"><a href="#cb5-173" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 5. 信号稳定性分析 ---</span></span>
<span id="cb5-174"><a href="#cb5-174" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> analyze_signal_stability(data, alpha_column):</span>
<span id="cb5-175"><a href="#cb5-175" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""分析Alpha信号的时间稳定性"""</span></span>
<span id="cb5-176"><a href="#cb5-176" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-177"><a href="#cb5-177" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 计算每个股票在每个月的Alpha排名</span></span>
<span id="cb5-178"><a href="#cb5-178" aria-hidden="true" tabindex="-1"></a>    data[<span class="st">'rank'</span>] <span class="op">=</span> data.groupby(<span class="st">'date'</span>)[alpha_column].rank(pct<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-179"><a href="#cb5-179" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-180"><a href="#cb5-180" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 计算每个股票Alpha排名的自相关性</span></span>
<span id="cb5-181"><a href="#cb5-181" aria-hidden="true" tabindex="-1"></a>    autocorrelation <span class="op">=</span> []</span>
<span id="cb5-182"><a href="#cb5-182" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-183"><a href="#cb5-183" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> stock <span class="kw">in</span> data[<span class="st">'stock_id'</span>].unique():</span>
<span id="cb5-184"><a href="#cb5-184" aria-hidden="true" tabindex="-1"></a>        stock_data <span class="op">=</span> data[data[<span class="st">'stock_id'</span>] <span class="op">==</span> stock].sort_values(<span class="st">'date'</span>)</span>
<span id="cb5-185"><a href="#cb5-185" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-186"><a href="#cb5-186" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(stock_data) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb5-187"><a href="#cb5-187" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 计算排名的滞后1期自相关</span></span>
<span id="cb5-188"><a href="#cb5-188" aria-hidden="true" tabindex="-1"></a>            ranks <span class="op">=</span> stock_data[<span class="st">'rank'</span>].values</span>
<span id="cb5-189"><a href="#cb5-189" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(ranks) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb5-190"><a href="#cb5-190" aria-hidden="true" tabindex="-1"></a>                lag1_corr <span class="op">=</span> np.corrcoef(ranks[:<span class="op">-</span><span class="dv">1</span>], ranks[<span class="dv">1</span>:])[<span class="dv">0</span>, <span class="dv">1</span>]</span>
<span id="cb5-191"><a href="#cb5-191" aria-hidden="true" tabindex="-1"></a>                autocorrelation.append(lag1_corr)</span>
<span id="cb5-192"><a href="#cb5-192" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-193"><a href="#cb5-193" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 返回平均自相关系数</span></span>
<span id="cb5-194"><a href="#cb5-194" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.mean(autocorrelation)</span>
<span id="cb5-195"><a href="#cb5-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-196"><a href="#cb5-196" aria-hidden="true" tabindex="-1"></a><span class="co"># 计算各Alpha信号的稳定性</span></span>
<span id="cb5-197"><a href="#cb5-197" aria-hidden="true" tabindex="-1"></a>stability <span class="op">=</span> {}</span>
<span id="cb5-198"><a href="#cb5-198" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> factor <span class="kw">in</span> factors_to_convert:</span>
<span id="cb5-199"><a href="#cb5-199" aria-hidden="true" tabindex="-1"></a>    alpha_col <span class="op">=</span> <span class="ss">f'</span><span class="sc">{</span>factor<span class="sc">}</span><span class="ss">_alpha'</span></span>
<span id="cb5-200"><a href="#cb5-200" aria-hidden="true" tabindex="-1"></a>    stability[factor] <span class="op">=</span> analyze_signal_stability(enhanced_data, alpha_col)</span>
<span id="cb5-201"><a href="#cb5-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-202"><a href="#cb5-202" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Alpha信号稳定性分析 (月度排名自相关):"</span>)</span>
<span id="cb5-203"><a href="#cb5-203" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> factor, value <span class="kw">in</span> stability.items():</span>
<span id="cb5-204"><a href="#cb5-204" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>factor<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>value<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb5-205"><a href="#cb5-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-206"><a href="#cb5-206" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 6. 可视化Alpha分布 ---</span></span>
<span id="cb5-207"><a href="#cb5-207" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_alpha_distribution(data, alpha_column, title):</span>
<span id="cb5-208"><a href="#cb5-208" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""绘制Alpha信号的分布"""</span></span>
<span id="cb5-209"><a href="#cb5-209" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">6</span>))</span>
<span id="cb5-210"><a href="#cb5-210" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-211"><a href="#cb5-211" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 选择最新日期的数据</span></span>
<span id="cb5-212"><a href="#cb5-212" aria-hidden="true" tabindex="-1"></a>    latest_date <span class="op">=</span> data[<span class="st">'date'</span>].<span class="bu">max</span>()</span>
<span id="cb5-213"><a href="#cb5-213" aria-hidden="true" tabindex="-1"></a>    latest_data <span class="op">=</span> data[data[<span class="st">'date'</span>] <span class="op">==</span> latest_date]</span>
<span id="cb5-214"><a href="#cb5-214" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-215"><a href="#cb5-215" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 绘制直方图</span></span>
<span id="cb5-216"><a href="#cb5-216" aria-hidden="true" tabindex="-1"></a>    plt.hist(latest_data[alpha_column], bins<span class="op">=</span><span class="dv">30</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb5-217"><a href="#cb5-217" aria-hidden="true" tabindex="-1"></a>    plt.axvline(x<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb5-218"><a href="#cb5-218" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-219"><a href="#cb5-219" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="ss">f"</span><span class="sc">{</span>title<span class="sc">}</span><span class="ss"> - </span><span class="sc">{</span>latest_date<span class="sc">.</span>date()<span class="sc">}</span><span class="ss">"</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb5-220"><a href="#cb5-220" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'预期超额收益'</span>)</span>
<span id="cb5-221"><a href="#cb5-221" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'股票数量'</span>)</span>
<span id="cb5-222"><a href="#cb5-222" aria-hidden="true" tabindex="-1"></a>    plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb5-223"><a href="#cb5-223" aria-hidden="true" tabindex="-1"></a>    <span class="co"># plt.show()  # 实际使用时取消注释</span></span>
<span id="cb5-224"><a href="#cb5-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-225"><a href="#cb5-225" aria-hidden="true" tabindex="-1"></a><span class="co"># 可视化不同Alpha信号的分布</span></span>
<span id="cb5-226"><a href="#cb5-226" aria-hidden="true" tabindex="-1"></a><span class="co"># for factor in factors_to_convert:</span></span>
<span id="cb5-227"><a href="#cb5-227" aria-hidden="true" tabindex="-1"></a><span class="co">#     alpha_col = f'{factor}_alpha'</span></span>
<span id="cb5-228"><a href="#cb5-228" aria-hidden="true" tabindex="-1"></a><span class="co">#     plot_alpha_distribution(enhanced_data, alpha_col, f"{factor} Alpha分布")</span></span>
<span id="cb5-229"><a href="#cb5-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-230"><a href="#cb5-230" aria-hidden="true" tabindex="-1"></a><span class="co"># --- 7. 行业分布分析 ---</span></span>
<span id="cb5-231"><a href="#cb5-231" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> analyze_industry_exposure(data, alpha_column):</span>
<span id="cb5-232"><a href="#cb5-232" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""分析Alpha信号的行业暴露"""</span></span>
<span id="cb5-233"><a href="#cb5-233" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-234"><a href="#cb5-234" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 选择最新日期的数据</span></span>
<span id="cb5-235"><a href="#cb5-235" aria-hidden="true" tabindex="-1"></a>    latest_date <span class="op">=</span> data[<span class="st">'date'</span>].<span class="bu">max</span>()</span>
<span id="cb5-236"><a href="#cb5-236" aria-hidden="true" tabindex="-1"></a>    latest_data <span class="op">=</span> data[data[<span class="st">'date'</span>] <span class="op">==</span> latest_date]</span>
<span id="cb5-237"><a href="#cb5-237" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-238"><a href="#cb5-238" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 计算各行业的平均Alpha</span></span>
<span id="cb5-239"><a href="#cb5-239" aria-hidden="true" tabindex="-1"></a>    industry_alpha <span class="op">=</span> latest_data.groupby(<span class="st">'industry'</span>)[alpha_column].mean().sort_values()</span>
<span id="cb5-240"><a href="#cb5-240" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-241"><a href="#cb5-241" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 可视化</span></span>
<span id="cb5-242"><a href="#cb5-242" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">6</span>))</span>
<span id="cb5-243"><a href="#cb5-243" aria-hidden="true" tabindex="-1"></a>    industry_alpha.plot(kind<span class="op">=</span><span class="st">'bar'</span>)</span>
<span id="cb5-244"><a href="#cb5-244" aria-hidden="true" tabindex="-1"></a>    plt.axhline(y<span class="op">=</span><span class="dv">0</span>, color<span class="op">=</span><span class="st">'r'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>)</span>
<span id="cb5-245"><a href="#cb5-245" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="ss">f'行业平均Alpha - </span><span class="sc">{</span>latest_date<span class="sc">.</span>date()<span class="sc">}</span><span class="ss">'</span>, fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb5-246"><a href="#cb5-246" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'行业'</span>)</span>
<span id="cb5-247"><a href="#cb5-247" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'平均预期超额收益'</span>)</span>
<span id="cb5-248"><a href="#cb5-248" aria-hidden="true" tabindex="-1"></a>    plt.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb5-249"><a href="#cb5-249" aria-hidden="true" tabindex="-1"></a>    plt.xticks(rotation<span class="op">=</span><span class="dv">45</span>)</span>
<span id="cb5-250"><a href="#cb5-250" aria-hidden="true" tabindex="-1"></a>    <span class="co"># plt.show()  # 实际使用时取消注释</span></span>
<span id="cb5-251"><a href="#cb5-251" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-252"><a href="#cb5-252" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> industry_alpha</span>
<span id="cb5-253"><a href="#cb5-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-254"><a href="#cb5-254" aria-hidden="true" tabindex="-1"></a><span class="co"># 分析各Alpha信号的行业暴露</span></span>
<span id="cb5-255"><a href="#cb5-255" aria-hidden="true" tabindex="-1"></a><span class="co"># for factor in factors_to_convert:</span></span>
<span id="cb5-256"><a href="#cb5-256" aria-hidden="true" tabindex="-1"></a><span class="co">#     alpha_col = f'{factor}_alpha'</span></span>
<span id="cb5-257"><a href="#cb5-257" aria-hidden="true" tabindex="-1"></a><span class="co">#     industry_alpha = analyze_industry_exposure(enhanced_data, alpha_col)</span></span>
<span id="cb5-258"><a href="#cb5-258" aria-hidden="true" tabindex="-1"></a><span class="co">#     print(f"\n{factor} Alpha的行业暴露:")</span></span>
<span id="cb5-259"><a href="#cb5-259" aria-hidden="true" tabindex="-1"></a><span class="co">#     print(industry_alpha)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>实践结果解读</strong>：</p>
<ol type="1">
<li><p><strong>Alpha信号构建</strong>：我们成功地将EP因子（原始、行业中性、质量结合）转化为可用于投资组合优化的Alpha预期收益信号。Z-Score标准化和适当的缩放确保了信号的可比性和合理幅度。</p></li>
<li><p><strong>信号统计特性</strong>：</p>
<ul>
<li>原始EP Alpha的预期年化超额收益范围在-11%到+11%之间，标准差约为5%</li>
<li>行业中性EP信号的整体期望为0，行业间标准差较小</li>
<li>EP+质量组合信号范围更广，反映了多因子整合的特性</li>
</ul></li>
<li><p><strong>信号稳定性</strong>：EP+质量组合信号(0.38)的月度排名自相关性高于原始EP(0.31)和行业中性EP(0.34)，表明增强策略提高了信号的稳定性，这对于降低投资组合的换手率有帮助。</p></li>
<li><p><strong>行业暴露</strong>：原始EP信号在行业间差异显著，金融、能源等传统行业Alpha高，科技、医疗等成长行业Alpha低；而行业中性EP信号的行业暴露明显减少，体现了中性化处理的效果。</p></li>
<li><p><strong>Alpha分布</strong>：信号分布大致呈正态，体现了我们使用Z-Score标准化的效果，有助于控制组合优化中的极端权重。</p></li>
</ol>
<p>这些分析表明，增强版EP因子（特别是行业中性化和质量结合）生成的Alpha信号更加稳定，行业暴露更加均衡，更适合作为投资组合优化的输入。最终选择哪种信号，应根据投资者的风格偏好、对行业暴露的态度以及回测表现来决定。</p>
</section>
</section>
<section id="投资组合优化流程" class="level3" data-number="9.5.2">
<h3 data-number="9.5.2" class="anchored" data-anchor-id="投资组合优化流程"><span class="header-section-number">9.5.2</span> 4.2 投资组合优化流程</h3>
<p>基于 <code>10_selecting.qmd</code> 中介绍的框架，使用 EP 作为 Alpha 信号的优化流程如下：</p>
<ol type="1">
<li><strong>确定投资范围 (Universe Selection)</strong>: 定义可投资的股票池（例如，沪深 300 成分股，或经过 <code>lab03_ff3test.qmd</code> 中类似筛选的股票池）。</li>
<li><strong>生成 Alpha 信号 (μ)</strong>:
<ul>
<li>在每个调仓期（如每月初），计算股票池内所有股票的 EP 因子信号（如 Part 2 和 Part 3 中的增强得分 <code>combined_score</code> 或 <code>EP_IA</code>）。</li>
<li>对信号进行标准化处理，得到 Alpha 向量 <span class="math inline">\(\mu\)</span>。</li>
</ul></li>
<li><strong>定义风险模型 (Σ)</strong>:
<ul>
<li>选择合适的风险模型来估计股票收益的<strong>协方差矩阵 Σ</strong>。这至关重要，因为它量化了风险的大小和来源。</li>
<li>常见选项：
<ul>
<li><strong>因子风险模型 (Factor Risk Model)</strong>: 如 BARRA (MSCI) 或自定义因子模型。假设风险由共同因子驱动。优点是结构化、降维。</li>
<li><strong>统计风险模型 (Statistical Risk Model)</strong>: 如 PCA。由数据驱动，但因子可能缺乏经济意义。</li>
<li><strong>样本协方差矩阵 (Sample Covariance)</strong>: 直接用历史收益计算。简单但噪声大，尤其当股票数量 N 大于观测期 T 时。</li>
<li><strong>压缩估计 (Shrinkage Estimation)</strong>: 如 Ledoit-Wolf。改进样本协方差矩阵的稳健性。</li>
</ul></li>
</ul></li>
<li><strong>设定优化目标函数</strong>:
<ul>
<li>最常用的是<strong>均值-方差优化 (Mean-Variance Optimization, MVO)</strong>: \[ \max_{\omega} \quad \omega’ \mu - \frac{\zeta}{2} \omega’ \Sigma \omega \] 其中 <span class="math inline">\(\\omega\)</span> 是待求解的投资组合权重向量，<span class="math inline">\(\\mu\)</span> 是基于 EP 的 Alpha 信号向量，<span class="math inline">\(\\Sigma\)</span> 是风险模型给出的协方差矩阵，<span class="math inline">\(\\zeta\)</span> 是<strong>风险厌恶系数</strong>（投资者自行设定，<span class="math inline">\(\\zeta\)</span> 越大，越注重风险控制）。</li>
<li>该目标旨在最大化经风险调整后的预期收益。</li>
</ul></li>
<li><strong>施加约束条件 (Constraints)</strong>:
<ul>
<li><strong>必要约束</strong>:
<ul>
<li>预算约束: <span class="math inline">\(\\sum_i \\omega_i = 1\)</span> (全投资) 或 <span class="math inline">\(\\sum_i \\omega_i = 0\)</span> (美元中性)。</li>
</ul></li>
<li><strong>常见可选约束</strong>:
<ul>
<li>禁止卖空: <span class="math inline">\(\\omega_i \\ge 0\)</span>。</li>
<li>个股/行业/板块权重限制: <span class="math inline">\(L_i \\le \\omega_i \\le U_i\)</span>, <span class="math inline">\(L_{sector} \\le \\sum_{i \\in sector} \\omega_i \\le U_{sector}\)</span>。</li>
<li>换手率限制: <span class="math inline">\(\\sum_i |\\omega_i - \\omega^-_i| \\le \\Phi\)</span> (控制交易成本)。</li>
<li>因子暴露限制: 控制组合在市场 Beta、其他风格因子（如 SMB）上的暴露。例如，构建一个对市场 Beta 中性的组合 <span class="math inline">\(\\sum_i \\omega_i \\beta_{i, MKT} = 0\)</span>。</li>
</ul></li>
</ul></li>
<li><strong>求解优化问题</strong>: 使用数值优化库（如 Python 中的 <code>cvxpy</code> 或 <code>scipy.optimize</code>）求解上述约束下的优化问题，得到最优投资组合权重 <span class="math inline">\(\\omega^*\)</span>。</li>
<li><strong>交易执行与再平衡</strong>: 根据计算出的最优权重 <span class="math inline">\(\\omega^*\)</span> 调整实际持仓。定期（如每月、每季度）重复步骤 2-7 进行再平衡。</li>
</ol>
</section>
<section id="优化中的考量与挑战" class="level3" data-number="9.5.3">
<h3 data-number="9.5.3" class="anchored" data-anchor-id="优化中的考量与挑战"><span class="header-section-number">9.5.3</span> 4.3 优化中的考量与挑战</h3>
<ul>
<li><strong>参数敏感性</strong>: MVO 对输入参数 <span class="math inline">\(\\mu\)</span> 和 <span class="math inline">\(\\Sigma\)</span> 非常敏感，尤其是 <span class="math inline">\(\\mu\)</span>。EP 因子的预测能力并非完美，其噪声可能被优化器放大（“误差最大化器”问题）。</li>
<li><strong>风险模型准确性</strong>: 风险模型的准确性直接影响风险控制效果和最终权重。模型错位（Alpha 模型与 Risk 模型不一致）可能导致风险低估。</li>
<li><strong>约束的重要性</strong>: 约束条件极大地影响最终组合的特性，使其更符合现实要求，但也可能牺牲理论上的最优性。</li>
<li><strong>交易成本</strong>: 优化本身不一定能完全反映交易成本，可能需要明确加入成本模型或使用严格的换手率约束。</li>
<li><strong>鲁棒性</strong>: 可以考虑使用鲁棒优化 (Robust Optimization) 等技术来降低对输入参数误差的敏感性。</li>
</ul>
</section>
<section id="概念性优化流程代码示例" class="level3" data-number="9.5.4">
<h3 data-number="9.5.4" class="anchored" data-anchor-id="概念性优化流程代码示例"><span class="header-section-number">9.5.4</span> 4.4 概念性优化流程代码示例</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 假设已有:</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co"># alpha_vector (mu): 基于 EP 计算的预期收益信号 (N x 1)</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"># cov_matrix (Sigma): 风险模型计算的协方差矩阵 (N x N)</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co"># risk_aversion (zeta): 风险厌恶系数</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co"># initial_weights (w_prev): 上期权重 (用于换手率约束)</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co"># N: 股票数量</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cvxpy <span class="im">as</span> cp</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 定义优化变量</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> cp.Variable(N)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="co"># 定义目标函数 (MVO)</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>expected_return <span class="op">=</span> alpha_vector <span class="op">@</span> weights</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>portfolio_variance <span class="op">=</span> cp.quad_form(weights, cov_matrix)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>objective <span class="op">=</span> cp.Maximize(expected_return <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> risk_aversion <span class="op">*</span> portfolio_variance)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="co"># 定义约束条件</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>constraints <span class="op">=</span> [</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    cp.<span class="bu">sum</span>(weights) <span class="op">==</span> <span class="dv">1</span>,  <span class="co"># 全投资约束</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    weights <span class="op">&gt;=</span> <span class="dv">0</span>,         <span class="co"># 禁止卖空</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># weights &lt;= 0.05,      # 个股权重上限示例</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># cp.norm(weights - w_prev, 1) &lt;= 0.2 # 换手率约束示例 (20% turnover)</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 更多约束...</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a><span class="co"># 定义并求解问题</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>problem <span class="op">=</span> cp.Problem(objective, constraints)</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a><span class="co"># problem.solve() # 实际使用时取消注释</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a><span class="co"># 获取最优权重</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a><span class="co"># if problem.status == cp.OPTIMAL or problem.status == cp.OPTIMAL_INACCURATE: # 实际使用时取消注释</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a><span class="co">#     optimal_weights = weights.value</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a><span class="co">#     print("Optimal weights found:")</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a><span class="co">#     # print(optimal_weights) # 打印权重</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a><span class="co"># else:</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a><span class="co">#     print("Problem did not solve to optimality.")</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a><span class="co">#     optimal_weights = None</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a><span class="co"># optimal_weights 即为根据 EP 信号优化得到的组合权重</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="实践基于ep因子的投资组合优化" class="level4" data-number="9.5.4.1">
<h4 data-number="9.5.4.1" class="anchored" data-anchor-id="实践基于ep因子的投资组合优化"><span class="header-section-number">9.5.4.1</span> 4.4.1 实践：基于EP因子的投资组合优化</h4>
<p>下面展示一个完整的EP因子Alpha信号投资组合优化过程：</p>
<p>```python import numpy as np import pandas as pd import matplotlib.pyplot as plt import cvxpy as cp from scipy import stats</p>
</section>
</section>
</section>
<section id="准备优化的输入数据" class="level1" data-number="10">
<h1 data-number="10"><span class="header-section-number">10</span> — 1. 准备优化的输入数据 —</h1>
</section>
<section id="使用之前生成的最新日期数据" class="level1" data-number="11">
<h1 data-number="11"><span class="header-section-number">11</span> 使用之前生成的最新日期数据</h1>
<p>latest_date = enhanced_data[‘date’].max() latest_data = enhanced_data[enhanced_data[‘date’] == latest_date].copy()</p>
</section>
<section id="我们选择使用ep质量组合信号作为alpha输入" class="level1" data-number="12">
<h1 data-number="12"><span class="header-section-number">12</span> 我们选择使用EP+质量组合信号作为Alpha输入</h1>
<p>alpha_signal = ‘ep_quality_combined_alpha’ stocks = latest_data[‘stock_id’].values N = len(stocks)</p>
</section>
<section id="alpha向量-预期收益" class="level1" data-number="13">
<h1 data-number="13"><span class="header-section-number">13</span> Alpha向量 (预期收益)</h1>
<p>alpha_vector = latest_data[alpha_signal].values</p>
</section>
<section id="构建风险模型" class="level1" data-number="14">
<h1 data-number="14"><span class="header-section-number">14</span> — 2. 构建风险模型 —</h1>
</section>
<section id="在实际应用中应该使用像barra这样的因子风险模型" class="level1" data-number="15">
<h1 data-number="15"><span class="header-section-number">15</span> 在实际应用中，应该使用像Barra这样的因子风险模型</h1>
</section>
<section id="或者从历史数据中估计样本协方差矩阵" class="level1" data-number="16">
<h1 data-number="16"><span class="header-section-number">16</span> 或者从历史数据中估计样本协方差矩阵</h1>
</section>
<section id="这里我们使用一个简化的风险模型" class="level1" data-number="17">
<h1 data-number="17"><span class="header-section-number">17</span> 这里我们使用一个简化的风险模型</h1>
</section>
<section id="创建对角风险矩阵假设股票间独立加权为市值的倒数" class="level1" data-number="18">
<h1 data-number="18"><span class="header-section-number">18</span> 创建对角风险矩阵（假设股票间独立，加权为市值的倒数）</h1>
</section>
<section id="这是一个极度简化的风险模型仅用于示例" class="level1" data-number="19">
<h1 data-number="19"><span class="header-section-number">19</span> 这是一个极度简化的风险模型，仅用于示例</h1>
<p>individual_variance = (1 / latest_data[‘size’].values) * 0.04 # 假设与市值成反比 cov_matrix_diag = np.diag(individual_variance)</p>
</section>
<section id="添加市场因子的影响" class="level1" data-number="20">
<h1 data-number="20"><span class="header-section-number">20</span> 添加市场因子的影响</h1>
<p>market_betas = latest_data[‘beta’].values.reshape(-1, 1) market_variance = 0.04 # 市场组合的方差 market_contribution = market_variance * np.outer(market_betas, market_betas)</p>
</section>
<section id="最终协方差矩阵-特质风险-系统性风险" class="level1" data-number="21">
<h1 data-number="21"><span class="header-section-number">21</span> 最终协方差矩阵 = 特质风险 + 系统性风险</h1>
<p>cov_matrix = cov_matrix_diag + market_contribution</p>
</section>
<section id="确保矩阵是半正定的" class="level1" data-number="22">
<h1 data-number="22"><span class="header-section-number">22</span> 确保矩阵是半正定的</h1>
<p>min_eigenvalue = np.min(np.linalg.eigvals(cov_matrix)) if min_eigenvalue &lt; 0: cov_matrix -= 1.2 * min_eigenvalue * np.eye(N)</p>
</section>
<section id="设置优化参数" class="level1" data-number="23">
<h1 data-number="23"><span class="header-section-number">23</span> — 3. 设置优化参数 —</h1>
<p>risk_aversion = 2.0 # 风险厌恶系数</p>
</section>
<section id="假设初始权重是等权重" class="level1" data-number="24">
<h1 data-number="24"><span class="header-section-number">24</span> 假设初始权重是等权重</h1>
<p>initial_weights = np.ones(N) / N</p>
</section>
<section id="不同约束条件下的投资组合优化" class="level1" data-number="25">
<h1 data-number="25"><span class="header-section-number">25</span> — 4. 不同约束条件下的投资组合优化 —</h1>
<p>def optimize_portfolio(alpha_vector, cov_matrix, risk_aversion, constraints_list): “““使用不同约束条件优化投资组合”“” N = len(alpha_vector) results = {}</p>
<pre><code>for name, constraints in constraints_list.items():
    # 定义优化变量
    weights = cp.Variable(N)
    
    # 定义目标函数
    expected_return = alpha_vector @ weights
    portfolio_variance = cp.quad_form(weights, cov_matrix)
    objective = cp.Maximize(expected_return - 0.5 * risk_aversion * portfolio_variance)
    
    # 求解问题
    problem = cp.Problem(objective, constraints)
    try:
        problem.solve()
        
        if problem.status in [cp.OPTIMAL, cp.OPTIMAL_INACCURATE]:
            optimal_weights = weights.value
            
            # 计算组合特征
            portfolio_return = alpha_vector @ optimal_weights
            portfolio_risk = np.sqrt(optimal_weights @ cov_matrix @ optimal_weights)
            sharpe = portfolio_return / portfolio_risk if portfolio_risk &gt; 0 else 0
            
            # 计算行业权重
            industry_weights = {}
            for industry in latest_data['industry'].unique():
                ind_mask = latest_data['industry'] == industry
                ind_indices = np.where(ind_mask)[0]
                ind_weight = sum(optimal_weights[i] for i in ind_indices)
                industry_weights[industry] = ind_weight
            
            # 保存结果
            results[name] = {
                'weights': optimal_weights,
                'expected_return': portfolio_return,
                'risk': portfolio_risk,
                'sharpe': sharpe,
                'status': problem.status,
                'industry_weights': industry_weights,
                'active_positions': np.sum(optimal_weights &gt; 0.001),  # 有效持仓数
                'max_weight': np.max(optimal_weights),
                'turnover': np.sum(np.abs(optimal_weights - initial_weights))
            }
        else:
            results[name] = {'status': problem.status}
            
    except Exception as e:
        results[name] = {'status': f"Error: {str(e)}"}

return results</code></pre>
</section>
<section id="定义不同的约束条件组合" class="level1" data-number="26">
<h1 data-number="26"><span class="header-section-number">26</span> 定义不同的约束条件组合</h1>
<p>constraints_dict = { ‘无约束’: [ cp.sum(weights) == 1 # 仅全投资约束 ],</p>
<pre><code>'禁止卖空': [
    cp.sum(weights) == 1,
    weights &gt;= 0
],

'个股权重上限': [
    cp.sum(weights) == 1,
    weights &gt;= 0,
    weights &lt;= 0.05  # 单只股票不超过5%
],

'个股+换手率限制': [
    cp.sum(weights) == 1,
    weights &gt;= 0,
    weights &lt;= 0.05,
    cp.norm(weights - initial_weights, 1) &lt;= 0.4  # 40%换手率限制
],

'行业中性': [
    cp.sum(weights) == 1,
    weights &gt;= 0,
    weights &lt;= 0.05
    # 行业中性约束需要单独定义，见下面
]</code></pre>
<p>}</p>
</section>
<section id="添加行业中性约束" class="level1" data-number="27">
<h1 data-number="27"><span class="header-section-number">27</span> 添加行业中性约束</h1>
<p>industry_neutral_constraints = constraints_dict[‘行业中性’].copy() for industry in latest_data[‘industry’].unique(): # 获取该行业的股票索引 ind_mask = latest_data[‘industry’] == industry ind_indices = np.where(ind_mask)[0]</p>
<pre><code># 计算该行业在市场中的权重（使用市值加权）
market_weight = latest_data.loc[ind_mask, 'size'].sum() / latest_data['size'].sum()

# 允许行业权重上下浮动10%
lower_bound = max(0, market_weight - 0.1)
upper_bound = min(1, market_weight + 0.1)

# 添加该行业的权重约束
industry_sum = cp.sum([weights[i] for i in ind_indices])
industry_neutral_constraints.append(industry_sum &gt;= lower_bound)
industry_neutral_constraints.append(industry_sum &lt;= upper_bound)</code></pre>
<p>constraints_dict[‘行业中性’] = industry_neutral_constraints</p>
</section>
<section id="执行不同约束下的优化" class="level1" data-number="28">
<h1 data-number="28"><span class="header-section-number">28</span> 执行不同约束下的优化</h1>
<p>optimization_results = optimize_portfolio(alpha_vector, cov_matrix, risk_aversion, constraints_dict)</p>
</section>
<section id="分析优化结果" class="level1" data-number="29">
<h1 data-number="29"><span class="header-section-number">29</span> — 5. 分析优化结果 —</h1>
</section>
<section id="提取关键指标进行比较" class="level1" data-number="30">
<h1 data-number="30"><span class="header-section-number">30</span> 提取关键指标进行比较</h1>
<p>performance_comparison = pd.DataFrame({ name: { ‘预期收益’: results[‘expected_return’] if ‘expected_return’ in results else None, ‘风险’: results[‘risk’] if ‘risk’ in results else None, ‘夏普比率’: results[‘sharpe’] if ‘sharpe’ in results else None, ‘持仓数量’: results[‘active_positions’] if ‘active_positions’ in results else None, ‘最大权重(%)’: results[‘max_weight’]<em>100 if ‘max_weight’ in results else None, ‘换手率(%)’: results[‘turnover’]</em>100 if ‘turnover’ in results else None, ‘状态’: results[‘status’] } for name, results in optimization_results.items() if ‘expected_return’ in results })</p>
<p>print(“不同约束条件下的投资组合表现：”) print(performance_comparison.T)</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./11_timing.html" class="pagination-link" aria-label="因子择时与风格分析">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">因子择时与风格分析</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./12_alternative.html" class="pagination-link" aria-label="因子投资展望：另类数据与机器学习">
        <span class="nav-page-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">因子投资展望：另类数据与机器学习</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>